import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from matplotlib.patches import Wedge
import time

EARTH_RADIUS = 6378.137  # km
# BASE_ORBITAL_SPEED_FACTOR = 0.001 # Reduced speed factor
BASE_ORBITAL_SPEED_FACTOR = 0.002 # Increased speed factor
LOWEST_ORBIT_RADIUS = EARTH_RADIUS + 200 # Reference radius for speed calculation
MU = 398600.4418  # Earth's gravitational parameter (km³/s²). Adjust units as needed.

class Orbit:
    def __init__(self, radius: float, inclination: float = 0):
        self.radius = radius
        self.satellites = []
        self.shuttles = []
        self.inclination = inclination

class LaunchPad:
    def __init__(self, radius: float, angle: float):
        self.position = radius
        self.angle = angle

class SpaceCraft:
    def __init__(self, radius: float, angle: float, velocity: float):
        self.radius = radius
        self.angle = angle
        # self.trajectory = [] # Trajectory will be managed by SimulateMission
        self.speed = velocity
        self.visible = True
        self.active = True

    def update(self, time_step):
        self.angle += self.speed * time_step
        self.angle %= (2 * np.pi) # Keep angle within [0, 2*pi]
        # Trajectory points are generated by simulation steps, not here directly for tanker
        # return self.position() # Return new position

    def predict(self, time):
        future_angle = self.angle + self.speed * time
        future_angle %= (2 * np.pi)
        return (self.radius * np.cos(future_angle), self.radius * np.sin(future_angle))

    def position(self):
        return (self.radius * np.cos(self.angle), self.radius * np.sin(self.angle))

class Satellite(SpaceCraft):
    def __init__(self, radius: float, angle: float, velocity: float):
        super().__init__(radius, angle, velocity)
        self.initial_angle = angle  # Store angle at mission start
        self.id = f"Sat-{int(radius)}-{angle:.2f}"

class Shuttle(SpaceCraft):
    def __init__(self, radius: float, angle: float, velocity: float):
        super().__init__(radius, angle, velocity)
        self.deployed = False
        self.id = f"Shuttle-{int(radius)}-{angle:.2f}"
        self.intercepted = False
        self.initial_angle: float | None = None # Angle at deployment
        self.deployment_time: float | None = None # Mission time at deployment
        self.recovery_time: float | None = None # Mission time at recovery

class Tanker(SpaceCraft):
    def __init__(self, radius: float, angle: float, velocity: float = 0, fuel: float = 1000.0):
        super().__init__(radius, angle, velocity)
        self.mode = "launch"  # launch, orbit, transfer, return
        self.fuel = fuel
        self.shuttles_deployed = []
        self.shuttles_recovered = []
        self.current_target = None
        # self.transfer_orbit = None # Transfer details managed by SimulateMission
        self.outbound = True  # True for outbound, False for return mission
        self.mission_events = []

    def add_event(self, mission_time, event_description):
        self.mission_events.append((mission_time, event_description))
        print(f"T+{mission_time:.2f}: {event_description}")

class HohmannTransfer:
    def __init__(self, r1, r2):
        self.r1 = r1  
        self.r2 = r2  
        self.a = (r1 + r2) / 2  
        self.MU = MU  # Use the global MU constant
        
        # Velocity calculations using MU
        self.v1 = np.sqrt(self.MU / r1)  # Initial circular velocity
        self.v2 = np.sqrt(self.MU / r2)  # Target circular velocity
        self.v_trans_1 = np.sqrt(self.MU * (2/r1 - 1/self.a))  # Transfer orbit at r1
        self.v_trans_2 = np.sqrt(self.MU * (2/r2 - 1/self.a))  # Transfer orbit at r2
        
        # Transfer time (half-period) using Kepler's Third Law
        self.transfer_time = np.pi * np.sqrt(self.a**3 / self.MU)  # Corrected with MU

class SimulateMission:
    def __init__(self, planet_radius: float, tanker: Tanker):
        self.planet_radius = planet_radius
        self.tanker = tanker
        self.launch_pads = []
        self.orbits = []
        self.satellites = []
        self.shuttles = []
        self.mission_clock = 0  # Mission time in arbitrary units
        self.events = []
        # self.transfer_trajectories = [] # Will use tanker_mission_trajectory
        self.tanker_mission_trajectory = [] # Stores (time, x, y) points for the entire mission
        self.initial_launch_angle = None # Store the angle of the launch pad used

    def add_launch_pad(self, launch_pad: LaunchPad):
        self.launch_pads.append(launch_pad)

    def add_orbit(self, radius: float, inclination: float = 0):
        orbit = Orbit(radius, inclination)
        self.orbits.append(orbit)
        return orbit
    
    def add_satellite(self, orbit: Orbit, angle: float, speed: float):
        # Physics-based speed using MU and actual orbit radius
        speed = np.sqrt(MU / orbit.radius) * BASE_ORBITAL_SPEED_FACTOR  # Corrected formula
        satellite = Satellite(orbit.radius, angle, speed)
        orbit.satellites.append(satellite)
        self.satellites.append(satellite)
        return satellite
    
    def deploy_shuttle(self, orbit: Orbit, angle: float, speed: float):
        shuttle = Shuttle(orbit.radius, angle, speed)
        orbit.shuttles.append(shuttle)
        self.shuttles.append(shuttle)
        self.tanker.shuttles_deployed.append(shuttle)
        return shuttle
    
    def calculate_best_launch_pad(self):
        # Find the launch pad that requires the least fuel to reach the target
        if not self.launch_pads:
            raise ValueError("No launch pads available")
            
        best_pad = self.launch_pads[0]
        min_fuel = float('inf')
        
        # Simple calculation - in reality would be more complex
        for pad in self.launch_pads:
            # Calculate estimated fuel based on distance to lowest orbit
            if self.orbits:
                fuel_needed = abs(self.orbits[0].radius - self.planet_radius) * 0.1
                if fuel_needed < min_fuel:
                    min_fuel = fuel_needed
                    best_pad = pad
        
        return best_pad, min_fuel
    
    def calculate_intercept_time(self, spacecraft1, spacecraft2):
        """Calculate time to intercept between two spacecraft"""
        if spacecraft1.speed == spacecraft2.speed:
            return float('inf')  # Same speed, never intercept unless already aligned
        
        # Calculate angular difference
        angle_diff = (spacecraft2.angle - spacecraft1.angle) % (2 * np.pi)
        
        # Calculate time for intercept (when angular difference becomes zero)
        # Relative angular velocity determines how quickly they close the gap
        relative_speed = abs(spacecraft1.speed - spacecraft2.speed)
        
        if relative_speed > 0:
            intercept_time = angle_diff / relative_speed
            return intercept_time
        return float('inf')
    
    def find_next_optimal_target(self, current_orbit_idx):
        """Find the next optimal satellite to intercept"""
        if current_orbit_idx >= len(self.orbits) - 1:
            # We're at the highest orbit already
            return None, None, float('inf')
        
        next_orbit = self.orbits[current_orbit_idx + 1]
        best_target = None
        min_wait_time = float('inf')
        optimal_transfer = None
        
        # Calculate Hohmann transfer parameters
        transfer = HohmannTransfer(self.tanker.radius, next_orbit.radius)
        
        # Need tanker's current position accurately
        current_tanker_angle = self.tanker.angle % (2 * np.pi)

        for satellite in next_orbit.satellites:
            # Calculate current angular positions
            current_satellite_angle = satellite.angle % (2 * np.pi)
            
            # Calculate where satellite will be after transfer time
            satellite_future_angle = (current_satellite_angle +
                                      satellite.speed * transfer.transfer_time) % (2 * np.pi)

            # Calculate required starting angle for tanker for Hohmann transfer
            # Tanker needs to start burn such that it arrives 180 deg ahead of satellite
            # Arrival angle of tanker should be `satellite_future_angle - pi`
            # The transfer takes `pi` radians in angular distance itself relative to center.
            # Required departure angle is `satellite_future_angle - pi`
            required_departure_angle = (satellite_future_angle - np.pi) % (2 * np.pi)

            # Calculate how long tanker needs to wait in current orbit to reach departure angle
            angle_to_travel = (required_departure_angle - current_tanker_angle) % (2 * np.pi)
            # Ensure positive wait time calculation
            # wait_time = angle_to_travel / self.tanker.speed if self.tanker.speed > 0 else float('inf')
            if self.tanker.speed > 0:
                 # Adjust angle_to_travel to be positive if needed
                 if angle_to_travel < 0: angle_to_travel += 2 * np.pi
                 wait_time = angle_to_travel / self.tanker.speed
            elif angle_to_travel == 0:
                 wait_time = 0
            else:
                 wait_time = float('inf')

            if wait_time < min_wait_time:
                min_wait_time = wait_time
                best_target = satellite
                optimal_transfer = transfer
        
        return best_target, optimal_transfer, min_wait_time
    
    def find_next_shuttle_target(self, current_orbit_idx):
        """Find the next shuttle to intercept on return journey"""
        if current_orbit_idx <= 0:
            # We're at the lowest orbit already
            return None, None, float('inf')
        
        next_orbit = self.orbits[current_orbit_idx - 1]
        best_target = None
        min_wait_time = float('inf')
        optimal_transfer = None
        
        # Calculate Hohmann transfer parameters
        transfer = HohmannTransfer(self.tanker.radius, next_orbit.radius)
        
        # Need tanker's current position accurately
        current_tanker_angle = self.tanker.angle % (2 * np.pi)

        for shuttle in next_orbit.shuttles:
            if shuttle in self.tanker.shuttles_recovered or not shuttle.active:
                continue  # Skip already recovered shuttles
                
            # Calculate current angular positions
            current_shuttle_angle = shuttle.angle % (2 * np.pi)
            
            # Calculate where shuttle will be after transfer time
            shuttle_future_angle = (current_shuttle_angle +
                                   shuttle.speed * transfer.transfer_time) % (2 * np.pi)

            # Calculate required starting angle for tanker for rendezvous
            # Tanker needs to arrive at the same angle as the shuttle
            # The transfer covers pi radians angular distance relative to center.
            # Required departure angle is shuttle_future_angle - pi
            required_departure_angle = (shuttle_future_angle - np.pi) % (2 * np.pi)

            # Calculate how long tanker needs to wait in current orbit
            angle_to_travel = (required_departure_angle - current_tanker_angle) % (2 * np.pi)
            # wait_time = angle_to_travel / self.tanker.speed if self.tanker.speed > 0 else float('inf')
            if self.tanker.speed > 0:
                 # Adjust angle_to_travel to be positive if needed
                 if angle_to_travel < 0: angle_to_travel += 2 * np.pi
                 wait_time = angle_to_travel / self.tanker.speed
            elif angle_to_travel == 0:
                 wait_time = 0
            else:
                 wait_time = float('inf')

            if wait_time < min_wait_time:
                min_wait_time = wait_time
                best_target = shuttle
                optimal_transfer = transfer
        
        return best_target, optimal_transfer, min_wait_time
    
    def execute_hohmann_transfer(self, transfer):
        start_angle = self.tanker.angle % (2 * np.pi)
        start_radius = self.tanker.radius
        steps = 200
        transfer_trajectory_points = []
        start_time = self.mission_clock
        start_pos_x = start_radius * np.cos(start_angle)
        start_pos_y = start_radius * np.sin(start_angle)
        transfer_trajectory_points.append((start_time, start_pos_x, start_pos_y))

        a = transfer.a
        e = abs(transfer.r2 - transfer.r1) / (transfer.r1 + transfer.r2)
        transfer_time = transfer.transfer_time  # Use pre-calculated MU-based value
        if transfer_time <= 0: # Avoid division by zero if radii are equal
             return transfer_trajectory_points

        angle_of_periapsis = 0 # Initialize
        if transfer.r1 < transfer.r2:  # Outward
            # start_true_anomaly = 0
            # end_true_anomaly = np.pi
            angle_of_periapsis = start_angle # Periapsis is at the start point
        else:  # Inward
            # start_true_anomaly = np.pi
            # end_true_anomaly = 0
            # For inward, apoapsis is at start point, angle is start_angle
            # Periapsis is 180 degrees away *before* the start point in terms of angle.
            angle_of_periapsis = (start_angle - np.pi) % (2*np.pi) # Periapsis angle relative to center

        # Recalculate time step based on potentially capped steps
        actual_time_step = transfer_time / steps

        for i in range(1, steps + 1):
            # Calculate time fraction for Kepler's equation
            frac = i / steps
            mean_anomaly = frac * np.pi  # 0 to π for half-orbit transfer

            # Newton-Raphson solver for Eccentric Anomaly (E)
            E = mean_anomaly  # Initial guess
            for _ in range(10):  # 10 iterations for precision
                # Need to handle potential division by zero if e=1 (parabolic) or near 1
                denominator = (1 - e * np.cos(E))
                if abs(denominator) < 1e-9:
                    # Avoid division by zero, maybe break or use a different method
                    # For Hohmann transfers e is typically < 1, so this might be overly cautious
                    E = mean_anomaly # Fallback? Or handle error appropriately
                    break
                delta_E = (E - e * np.sin(E) - mean_anomaly) / denominator
                E -= delta_E
                if abs(delta_E) < 1e-6:
                    break

            # Calculate true anomaly (theta)
            true_anomaly = 2 * np.arctan2(
                np.sqrt(1 + e) * np.sin(E / 2),
                np.sqrt(1 - e) * np.cos(E / 2)
            )

            # For inward transfers, true anomaly goes from pi towards 0 (or 2pi)
            # Our calculation yields 0 to pi based on E from 0 to pi.
            # Adjust true anomaly if it's an inward transfer
            if transfer.r1 > transfer.r2:
                 true_anomaly = np.pi + (np.pi - true_anomaly) # Should map E=0..pi to true_anomaly=pi..2pi

            # Calculate position (r, inertial_angle)
            r = a * (1 - e**2) / (1 + e * np.cos(true_anomaly))
            inertial_angle = (angle_of_periapsis + true_anomaly) % (2 * np.pi)
            pos_x = r * np.cos(inertial_angle)
            pos_y = r * np.sin(inertial_angle)

            # --- Update other objects during this time step --- 
            current_time_step_start = start_time + (i - 1) * actual_time_step
            current_time_step_end = start_time + i * actual_time_step

            # Use the actual_time_step calculated for the transfer leg
            for satellite in self.satellites:
                 if satellite.active:
                     satellite.update(actual_time_step)
            for shuttle in self.shuttles:
                 if shuttle.active:
                     shuttle.update(actual_time_step)
            # --- End update other objects ---

            # Sync mission clock to the end of this step
            self.mission_clock = current_time_step_end

            # Append calculated position with the time at the END of this step
            transfer_trajectory_points.append((self.mission_clock, pos_x, pos_y))

            # Update tanker's internal state for the *next* step or final state
            # We update radius/angle here, but speed is only set finally
            self.tanker.radius = r
            self.tanker.angle = inertial_angle

        # Final state update after loop completion
        # The last point in transfer_trajectory_points should already be the correct final position.
        # We just need to ensure the tanker object's state matches precisely.
        final_calculated_angle = inertial_angle % (2 * np.pi) # Use the angle from the last step
        self.tanker.radius = transfer.r2 # Ensure exact final radius
        self.tanker.angle = final_calculated_angle # Ensure exact final angle from calculation

        # Set final speed for the new circular orbit
        self.tanker.speed = np.sqrt(MU / transfer.r2) * BASE_ORBITAL_SPEED_FACTOR
        return transfer_trajectory_points

    def simulate_launch(self, tanker: Tanker, target_orbit: Orbit, target_angle: float):
        """Simulate launch from planet to first orbit with proper timing"""
        # Start position
        start_angle = tanker.angle
        
        # Generate trajectory
        steps = 50
        final_radius = target_orbit.radius
        launch_trajectory_points = [] # Local list
        
        # Clear previous trajectory --> NO!
        # tanker.trajectory = []

        # Add initial position with current time
        start_time = self.mission_clock
        start_pos = tanker.position()
        launch_trajectory_points.append((start_time, start_pos[0], start_pos[1]))

        # Estimate total launch time (arbitrary for now)
        # This needs to be consistent with how mission_clock is updated
        estimated_launch_duration = 5.0 # Arbitrary duration for launch segment visual

        for i in range(1, steps + 1):
            t = i / steps
            # Interpolate radius from planet radius to orbit radius
            r = self.planet_radius + t * (final_radius - self.planet_radius)

            # Interpolate angle towards target_angle
            # Ensure shortest path interpolation
            delta_angle = target_angle - start_angle
            delta_angle = (delta_angle + np.pi) % (2 * np.pi) - np.pi # Normalize to [-pi, pi]
            angle = (start_angle + t * delta_angle) % (2 * np.pi)

            x = r * np.cos(angle)
            y = r * np.sin(angle)

            # --- Update other objects during this time step --- 
            # Calculate time elapsed in this specific step
            current_time = start_time + t * estimated_launch_duration
            time_step = current_time - self.mission_clock # Time elapsed since last update
            if time_step > 0: # Avoid zero time step on first iteration
                for satellite in self.satellites:
                     if satellite.active:
                         satellite.update(time_step)
                for shuttle in self.shuttles:
                     if shuttle.active:
                         shuttle.update(time_step)
            # --- End update other objects ---

            # Update mission time proportionally through the estimated duration
            self.mission_clock = current_time

        # Update tanker position
        tanker.radius = final_radius
        tanker.angle = target_angle % (2 * np.pi)
        
        # Set tanker speed to match orbital velocity using consistent formula
        tanker.speed = np.sqrt(MU / tanker.radius) * BASE_ORBITAL_SPEED_FACTOR # Corrected formula
        
        # Add mission event
        tanker.add_event(self.mission_clock, f"Launched to orbit {final_radius:.1f} km at angle {target_angle:.2f} rad")
        
        return launch_trajectory_points # Return points
    
    def simulate_reentry(self, tanker: Tanker, target_landing_angle: float):
        """Simulate reentry from lowest orbit to planet surface, targeting landing angle"""
        # Start position
        start_radius = tanker.radius
        start_angle = tanker.angle % (2 * np.pi)
        target_landing_angle %= (2 * np.pi)

        # Generate trajectory
        steps = 50
        reentry_trajectory_points = [] # Local list
        
        # Clear previous trajectory -> NO!
        # tanker.trajectory = []

        # Add starting point
        start_time = self.mission_clock
        start_pos = tanker.position()
        reentry_trajectory_points.append((start_time, start_pos[0], start_pos[1]))

        # Estimate total reentry time (arbitrary for now)
        estimated_reentry_duration = 5.0 # Arbitrary duration

        # Calculate shortest angle difference for interpolation
        delta_angle = target_landing_angle - start_angle
        delta_angle = (delta_angle + np.pi) % (2 * np.pi) - np.pi # Normalize to [-pi, pi]

        for i in range(1, steps + 1):
            t = i / steps
            # Interpolate radius from orbit to planet
            r = start_radius - t * (start_radius - self.planet_radius)

            # Interpolate angle towards target landing angle
            angle = (start_angle + t * delta_angle) % (2 * np.pi)

            # Add some inward curve? Optional. For now, direct path.
            # angle = start_angle + 0.3 * t # Old way

            x = r * np.cos(angle)
            y = r * np.sin(angle)

            # --- Update other objects during this time step --- 
            # Calculate time elapsed in this specific step
            current_time = start_time + t * estimated_reentry_duration
            time_step = current_time - self.mission_clock # Time elapsed since last update
            if time_step > 0: # Avoid zero time step on first iteration
                for satellite in self.satellites:
                     if satellite.active:
                         satellite.update(time_step)
                for shuttle in self.shuttles:
                     if shuttle.active:
                         shuttle.update(time_step)
            # --- End update other objects ---

            # Update mission time
            self.mission_clock = current_time

        # Update tanker final position (landed)
        tanker.radius = self.planet_radius
        tanker.angle = target_landing_angle
        tanker.speed = 0 # Landed
        tanker.active = False

        # Add mission event
        tanker.add_event(self.mission_clock, "Successful reentry and landing complete")
        
        return reentry_trajectory_points # Return points
    
    def deploy_shuttle_to_orbit(self, orbit: Orbit):
        """Deploy a shuttle to the current orbit moving in opposite direction"""
        # Create a shuttle at the tanker's current position
        shuttle_speed = self.tanker.speed # Deploy with same speed magnitude initially
        deployment_angle = self.tanker.angle
        deployment_time = self.mission_clock

        shuttle = self.deploy_shuttle(
            orbit,
            deployment_angle,
            -shuttle_speed  # Opposite direction
        )

        # Store deployment info
        shuttle.initial_angle = deployment_angle
        shuttle.deployment_time = deployment_time
        shuttle.deployed = True

        # Add mission event
        self.tanker.add_event(
            self.mission_clock, 
            f"Deployed shuttle in orbit {orbit.radius:.1f} km moving in opposite direction"
        )
        
        return shuttle
    
    def recover_shuttle(self, shuttle: Shuttle):
        """Recover a shuttle during rendezvous"""
        if shuttle not in self.tanker.shuttles_deployed:
            return False
        
        shuttle.intercepted = True
        shuttle.active = False
        shuttle.recovery_time = self.mission_clock # Record recovery time
        self.tanker.shuttles_recovered.append(shuttle)
        
        # Add mission event
        self.tanker.add_event(
            self.mission_clock, 
            f"Recovered shuttle from orbit {shuttle.radius:.1f} km"
        )
        
        return True
    
    def wait_in_orbit(self, wait_time):
        """Wait in current orbit for the specified time"""
        start_angle = self.tanker.angle
        # Determine number of steps based on wait time and a desired time resolution
        time_resolution = 0.1 # How often to sample points during wait
        steps = max(1, int(wait_time / time_resolution))
        # --- CAP THE STEPS --- #
        max_wait_steps = 1000
        steps = min(steps, max_wait_steps)
        # Recalculate time step based on potentially capped steps
        actual_time_step = wait_time / steps

        wait_trajectory_points = [] # Local list for (time, x, y)

        # Add starting point of the wait phase
        start_time = self.mission_clock
        start_pos = self.tanker.position()
        # --- DEBUG: Print first wait point info --- #
        # print(f"DEBUG: Wait start point: T={start_time:.2f}, X={start_pos[0]:.2f}, Y={start_pos[1]:.2f} (Tanker R={self.tanker.radius:.1f}, Angle={self.tanker.angle:.3f})")
        # --- END DEBUG ---
        wait_trajectory_points.append((start_time, start_pos[0], start_pos[1]))

        for i in range(steps):
            # Update satellites and shuttles first (their state at start of interval)
            for satellite in self.satellites:
                if satellite.active:
                    satellite.update(actual_time_step)

            for shuttle in self.shuttles:
                if shuttle.active:
                    shuttle.update(actual_time_step)

            # Update tanker
            self.tanker.update(actual_time_step)

            # Update mission clock *after* updating positions for this step
            self.mission_clock += actual_time_step
            current_pos = self.tanker.position()
            wait_trajectory_points.append((self.mission_clock, current_pos[0], current_pos[1])) # Add point with updated time

        if wait_time > 1:
            self.tanker.add_event(
                self.mission_clock,
                f"Waited in orbit {self.orbit_index_to_string(self.find_current_orbit_index())} for {wait_time:.2f} time units"
            )
        
        return wait_trajectory_points # Return points

    def find_current_orbit_index(self):
        """Find the index of the orbit the tanker is currently in."""
        for idx, orbit in enumerate(self.orbits):
            # Allow for small tolerance in radius comparison
            if abs(self.tanker.radius - orbit.radius) < 1.0:
                return idx
        return -1 # Not in a defined orbit (e.g., during transfer)

    def orbit_index_to_string(self, index):
        if 0 <= index < len(self.orbits):
            return f"{self.orbits[index].radius:.1f} km"
        return "Unknown Orbit"

    def simulate_mission(self):
        """Simulate the entire mission with multiple transfers and shuttle deployments"""
        # Sort orbits by radius
        self.orbits.sort(key=lambda x: x.radius)
        
        if not self.orbits:
            print("No orbits available for mission")
            return
        
        # Get best launch pad
        best_pad, fuel_needed = self.calculate_best_launch_pad()
        self.tanker.angle = best_pad.angle
        self.initial_launch_angle = best_pad.angle # Store for return
        self.tanker.radius = self.planet_radius # Ensure tanker starts on surface

        # Add starting point to trajectory
        self.tanker_mission_trajectory.append((0.0, self.tanker.position()[0], self.tanker.position()[1]))

        # --- OUTBOUND MISSION (DEPLOYMENT PHASE) ---
        self.tanker.outbound = True
        print("Starting Outbound Phase...")
        
        # Find best satellite in lowest orbit to intercept
        lowest_orbit = self.orbits[0]
        best_target = None
        min_angle_diff = float('inf')
        
        for satellite in lowest_orbit.satellites:
            angle_diff = abs((satellite.angle - self.tanker.angle) % (2 * np.pi))
            # Normalize angle diff
            angle_diff = min(angle_diff, 2*np.pi - angle_diff)
            if angle_diff < min_angle_diff:
                min_angle_diff = angle_diff
                best_target = satellite
        
        if best_target:
            print(f"Selected initial target: {best_target.id}")
            # Calculate future position of satellite for intercept
            flight_time = (lowest_orbit.radius - self.planet_radius) * 0.01
            future_angle = (best_target.angle + best_target.speed * flight_time) % (2 * np.pi)
            
            # Launch to lowest orbit timed for intercept
            self.tanker.add_event(0, "Mission started - launching to first orbit")
            # Target angle calculation needs review - launch aims for rendezvous point
            # Estimate flight time based on simple velocity (needs improvement)
            # Simplistic flight time estimate for launch timing:
            # delta_r = lowest_orbit.radius - self.planet_radius
            # avg_vel_est = 50 # km/time_unit? highly arbitrary placeholder
            # flight_time_est = delta_r / avg_vel_est if avg_vel_est else 10
            # Instead of estimating flight time here, simulate_launch handles time

            # We need to find the *launch time* so intercept occurs after launch duration.
            # Let launch_duration be the time it takes simulate_launch (e.g., estimated_launch_duration)
            launch_duration = 5.0 # Must match value used in simulate_launch
            # Target satellite position launch_duration *after* we launch.
            # But when do we launch? We need to wait until satellite is in right place.

            # Calculate satellite position at T=launch_duration (relative to T=0)
            initial_target_pos_at_launch_end = (best_target.angle + best_target.speed * launch_duration) % (2 * np.pi)

            # Our launch target angle should be this angle.
            launch_target_angle = initial_target_pos_at_launch_end

            # However, we might need to wait on the launchpad for the satellite to reach the correct phase.
            # This simple model doesn't include launch window calculations. Launching immediately.

            print(f"Launching to angle: {launch_target_angle:.2f} rad")
            launch_traj = self.simulate_launch(self.tanker, lowest_orbit, launch_target_angle)
            self.tanker_mission_trajectory.extend(launch_traj)
            print(f"Arrived in orbit {lowest_orbit.radius:.1f} km.")

            # Deploy first shuttle in the lowest orbit
            print(f"Deploying shuttle in orbit {lowest_orbit.radius:.1f} km...")
            self.deploy_shuttle_to_orbit(lowest_orbit)
            
            # Process each orbit for transfer
            current_orbit_idx = 0
            
            while current_orbit_idx < len(self.orbits) - 1:
                print(f"\nPlanning transfer from orbit {current_orbit_idx} ({self.orbits[current_orbit_idx].radius:.1f} km)")
                # Find next target
                next_target, transfer, wait_time = self.find_next_optimal_target(current_orbit_idx)
                
                if next_target and transfer:
                    print(f"  Found optimal target: {next_target.id} in orbit {current_orbit_idx + 1}")
                    print(f"  Calculated wait time: {wait_time:.2f}")
                    
                    # Wait in current orbit if needed
                    if wait_time > 1e-3: # Wait if time is non-negligible
                        self.tanker.add_event(
                            self.mission_clock,
                            f"Waiting {wait_time:.2f} time units in orbit {self.orbit_index_to_string(current_orbit_idx)} for optimal transfer window to orbit {self.orbits[current_orbit_idx+1].radius:.1f} km"
                        )
                        wait_traj = self.wait_in_orbit(wait_time)
                        self.tanker_mission_trajectory.extend(wait_traj)
                    
                    # Calculate target angle after transfer (arrival is 180 deg from satellite)
                    # Predict satellite angle after total time (wait + transfer)
                    total_time_to_arrival = wait_time + transfer.transfer_time
                    # For outbound transfers
                    target_future_angle = (next_target.angle + next_target.speed * total_time_to_arrival) % (2 * np.pi)
                    # arrival_angle = target_future_angle  # REMOVED - Transfer calculates its end angle
                    # transfer_traj = self.execute_hohmann_transfer(transfer, arrival_angle) # OLD CALL
                    # print(f"  Calculated arrival angle for transfer: {arrival_angle:.2f}") # REMOVED

                    # Execute Hohmann transfer
                    self.tanker.add_event(
                        self.mission_clock,
                        f"Beginning transfer from orbit {self.orbit_index_to_string(current_orbit_idx)} to orbit {self.orbits[current_orbit_idx+1].radius:.1f} km"
                    )
                    # transfer_traj = self.execute_hohmann_transfer(transfer, arrival_angle) # OLD CALL
                    transfer_traj = self.execute_hohmann_transfer(transfer) # NEW CALL
                    self.tanker_mission_trajectory.extend(transfer_traj)
                    print(f"  Completed transfer to orbit {self.orbits[current_orbit_idx+1].radius:.1f} km.")
                    
                    # Successfully transferred to next orbit - INCREMENT INDEX FIRST
                    current_orbit_idx += 1
                    print(f"  Now in orbit index: {current_orbit_idx}")
                    
                    # Deploy shuttle in NEW orbit - ENSURE THIS IS CALLED
                    print(f"Deploying shuttle in orbit {self.orbits[current_orbit_idx].radius:.1f} km...")
                    self.deploy_shuttle_to_orbit(self.orbits[current_orbit_idx])
                    
                    # Update mission status event AFTER deployment
                    self.tanker.add_event(
                        self.mission_clock,
                        f"Reached orbit {self.orbits[current_orbit_idx].radius:.1f} km, deployed shuttle targeting satellite {next_target.id}"
                    )
                else:
                    # No valid target found, end outbound phase
                    print(f"  No optimal target found from orbit {current_orbit_idx}. Ending outbound phase.")
                    break
            
            # --- RETURN MISSION (RECOVERY PHASE) ---
            print("\nStarting Return Phase...")
            self.tanker.outbound = False
            self.tanker.add_event(
                self.mission_clock, 
                "Beginning return mission phase - recovering shuttles"
            )
            
            # Process each orbit for return journey
            while current_orbit_idx > 0:
                # Find next shuttle to recover
                next_shuttle, transfer, wait_time = self.find_next_shuttle_target(current_orbit_idx)
                
                if next_shuttle and transfer:
                    # Wait in current orbit if needed
                    if wait_time > 1e-3: # Wait if time is non-negligible
                        self.tanker.add_event(
                            self.mission_clock,
                            f"Waiting {wait_time:.2f} time units in orbit {self.orbit_index_to_string(current_orbit_idx)} for optimal recovery window for shuttle in orbit {self.orbits[current_orbit_idx-1].radius:.1f} km"
                        )
                        wait_traj = self.wait_in_orbit(wait_time)
                        self.tanker_mission_trajectory.extend(wait_traj)
                    
                    # Calculate target angle after transfer (rendezvous with shuttle)
                    shuttle_future_angle = (next_shuttle.angle + next_shuttle.speed * (wait_time + transfer.transfer_time)) % (2 * np.pi)
                    # arrival_angle = shuttle_future_angle # REMOVED - Transfer calculates its end angle

                    # Execute Hohmann transfer
                    self.tanker.add_event(
                        self.mission_clock,
                        f"Beginning transfer from orbit {self.orbit_index_to_string(current_orbit_idx)} to recover shuttle in orbit {self.orbits[current_orbit_idx-1].radius:.1f} km"
                    )
                    # transfer_traj = self.execute_hohmann_transfer(transfer, arrival_angle) # OLD CALL
                    transfer_traj = self.execute_hohmann_transfer(transfer) # NEW CALL
                    self.tanker_mission_trajectory.extend(transfer_traj)
                    
                    # Successfully transferred to previous orbit
                    current_orbit_idx -= 1
                    
                    # Recover shuttle
                    self.recover_shuttle(next_shuttle)
                else:
                    # No valid shuttle found, continue to next lower orbit
                    if current_orbit_idx > 0: # Check if we can go lower
                        target_lower_orbit = self.orbits[current_orbit_idx - 1]
                        self.tanker.add_event(
                             self.mission_clock,
                             f"No active shuttles found in orbit {target_lower_orbit.radius:.1f} km. Proceeding downwards."
                        )
                        # Calculate direct transfer to next lower orbit
                        transfer = HohmannTransfer(self.tanker.radius, target_lower_orbit.radius)

                        # Just pick a reasonable target angle (e.g., 180 deg from current)
                        # target_angle = (self.tanker.angle + np.pi) % (2 * np.pi) # REMOVED

                        # Execute transfer
                        # transfer_traj = self.execute_hohmann_transfer(transfer, target_angle) # OLD CALL
                        transfer_traj = self.execute_hohmann_transfer(transfer) # NEW CALL
                        self.tanker_mission_trajectory.extend(transfer_traj)

                        # Update orbit index
                        current_orbit_idx -= 1
                    else:
                        # At lowest orbit, prepare for reentry
                        break
            
            # Final reentry from lowest orbit
            self.tanker.add_event(
                self.mission_clock,
                f"Return sequence complete - beginning reentry procedure to launch angle {self.initial_launch_angle:.2f} rad"
            )
            reentry_traj = self.simulate_reentry(self.tanker, self.initial_launch_angle)
            self.tanker_mission_trajectory.extend(reentry_traj)
            
            # Mission statistics
            shuttles_deployed = len(self.tanker.shuttles_deployed)
            shuttles_recovered = len(self.tanker.shuttles_recovered)
            mission_duration = self.mission_clock
            
            print("\n===== MISSION SUMMARY =====")
            print(f"Mission duration: {mission_duration:.2f} time units")
            print(f"Shuttles deployed: {shuttles_deployed}")
            print(f"Shuttles recovered: {shuttles_recovered}")
            print(f"Recovery rate: {shuttles_recovered/shuttles_deployed*100:.1f}%")
            print("==========================\n")
        
        else:
            print("No satellites found for intercept planning")
    
    def visualize(self):
        """Create an animation of the mission with satellites, shuttles, and trajectories"""
        fig, ax = plt.subplots(figsize=(10, 10))
        ax.set_aspect('equal')
        
        # Plot the planet
        planet = plt.Circle((0, 0), self.planet_radius, color='blue', alpha=0.5)
        ax.add_patch(planet)
        
        # Plot orbits
        for orbit in self.orbits:
            theta = np.linspace(0, 2*np.pi, 100)
            x = orbit.radius * np.cos(theta)
            y = orbit.radius * np.sin(theta)
            ax.plot(x, y, 'k--', alpha=0.3)
        
        # Plot launch pads
        for pad in self.launch_pads:
            pad_x = self.planet_radius * np.cos(pad.angle)
            pad_y = self.planet_radius * np.sin(pad.angle)
            ax.plot(pad_x, pad_y, 'bs', markersize=8)
        
        # Set plot limits based on the largest orbit
        max_radius = max(orbit.radius for orbit in self.orbits) * 1.2 if self.orbits else self.planet_radius * 2
        ax.set_xlim(-max_radius, max_radius)
        ax.set_ylim(-max_radius, max_radius)
        ax.grid(True)
        ax.set_title('Multi-Orbit Mission Simulation')
        
        # Add legend
        ax.plot([], [], 'ro', label='Satellites')
        ax.plot([], [], 'yo', label='Shuttles')
        ax.plot([], [], 'go', label='Tanker')
        ax.plot([], [], 'k--', label='Orbits')
        ax.plot([], [], 'g-', label='Tanker Path')
        ax.plot([], [], 'y-', label='Shuttle Paths')
        plt.legend(loc='upper right')
        
        # Animation setup
        satellite_markers = []
        for satellite in self.satellites:
            marker, = ax.plot([], [], 'ro', markersize=6)
            satellite_markers.append((satellite, marker))
        
        shuttle_markers = []
        for shuttle in self.shuttles:
            marker, = ax.plot([], [], 'yo', markersize=5) # Keep marker for current pos
            shuttle_markers.append((shuttle, marker))
        
        tanker_marker, = ax.plot([], [], 'go', markersize=8)
        tanker_full_path_line, = ax.plot([], [], 'g-', linewidth=1.5, alpha=0.3) # Line for full historical path

        # Text display for mission time and status
        time_text = ax.text(-max_radius*0.9, max_radius*0.9, '', fontsize=10)
        status_text = ax.text(-max_radius*0.9, max_radius*0.85, '', fontsize=10)
        
        def init():
            """Initialize animation"""
            tanker_marker.set_data([], [])
            tanker_full_path_line.set_data([], [])
            time_text.set_text('')
            status_text.set_text('')
            
            for _, marker in satellite_markers:
                marker.set_data([], [])
            
            for _, marker in shuttle_markers:
                marker.set_data([], [])
                
            return [tanker_marker, tanker_full_path_line, time_text, status_text] + \
                   [marker for _, marker in satellite_markers] + \
                   [marker for _, marker in shuttle_markers]
        
        def update(frame):
            """Update animation for the given frame"""
            # Map frame to animation step/index in the full trajectory
            num_trajectory_points = len(self.tanker_mission_trajectory)
            if num_trajectory_points < 2: return init() # Need at least 2 points

            # Calculate the corresponding index in the trajectory list
            trajectory_index = int((frame / (num_frames - 1)) * (num_trajectory_points - 1))
            trajectory_index = min(max(0, trajectory_index), num_trajectory_points - 1)

            # Get the time, x, y from the trajectory point
            current_time, current_x, current_y = self.tanker_mission_trajectory[frame]
            estimated_mission_time = current_time
            # Update satellite positions
            for satellite, marker in satellite_markers:
                if satellite.active:
                    satellite_angle = (satellite.initial_angle + satellite.speed * estimated_mission_time) % (2 * np.pi)
                    sat_x = satellite.radius * np.cos(satellite_angle)
                    sat_y = satellite.radius * np.sin(satellite_angle)
                    marker.set_data([sat_x], [sat_y])
                else:
                    marker.set_data([], [])

            # Update shuttle positions and paths
            for shuttle, marker in shuttle_markers:
                # --- DEBUG SHUTTLE --- #
                # print(f"Frame Time: {estimated_mission_time:.2f}, Shuttle: {shuttle.id}, Deployed: {shuttle.deployed}, Active: {shuttle.active}, DeployTime: {shuttle.deployment_time}, RecoverTime: {shuttle.recovery_time}") # Updated debug print
                
                # Determine if shuttle should be visible at this frame time
                is_deployed = shuttle.deployed and shuttle.deployment_time is not None and estimated_mission_time >= shuttle.deployment_time
                is_not_yet_recovered = shuttle.recovery_time is None or estimated_mission_time < shuttle.recovery_time
                should_be_visible = is_deployed and is_not_yet_recovered

                # Only draw if deployed and not yet recovered
                if should_be_visible:
                    # Calculate time elapsed since deployment
                    time_since_deployment = estimated_mission_time - shuttle.deployment_time
                    # Calculate position at estimated_mission_time
                    shuttle_angle = (shuttle.initial_angle + shuttle.speed * time_since_deployment) % (2 * np.pi)
                    shuttle_x = shuttle.radius * np.cos(shuttle_angle)
                    shuttle_y = shuttle.radius * np.sin(shuttle_angle)
                    marker.set_data([shuttle_x], [shuttle_y])
                    # print(f"  Drawing Shuttle {shuttle.id} at angle {shuttle_angle:.2f}") # Uncomment if needed
                else:
                    # Hide marker if not deployed yet, inactive, or recovered
                    marker.set_data([], [])

            # Update tanker position using the pre-calculated trajectory index
            if self.tanker_mission_trajectory:
                # tanker_pos = self.tanker_mission_trajectory[trajectory_index]
                # Use current_x, current_y obtained earlier
                tanker_marker.set_data([current_x], [current_y])

                # Update full historical trajectory line up to current point - REINSTATED
                trajectory_slice = self.tanker_mission_trajectory[:trajectory_index+1]
                if trajectory_slice:
                    tanker_full_path_line.set_data(
                        [pos[1] for pos in trajectory_slice], # Index 1 for x
                        [pos[2] for pos in trajectory_slice]  # Index 2 for y
                    )
                else:
                     tanker_full_path_line.set_data([],[])

            else:
                tanker_marker.set_data([], [])
                tanker_full_path_line.set_data([], [])

            # Update mission time text
            time_text.set_text(f'Mission Time: {estimated_mission_time:.2f}')
            
            # Update mission status text based on events
            status = "Pre-launch"
            for event_time, event_desc in self.tanker.mission_events:
                if event_time <= estimated_mission_time:
                    status = event_desc
            status_text.set_text(f'Status: {status}')
            
            return [tanker_marker, tanker_full_path_line, time_text, status_text] + \
                   [marker for _, marker in satellite_markers] + \
                   [marker for _, marker in shuttle_markers]
        
        # Create a reasonable number of frames based on trajectory points or time
        num_frames = max(500, len(self.tanker_mission_trajectory)) # More frames if long trajectory
        num_frames = min(num_frames, 2000) # Cap frames

        # Create the animation
        ani = FuncAnimation(
            fig,
            update,
            frames=num_frames,
            init_func=init,
            # blit=True, # Disable blit to potentially fix path artifacts
            blit=False,
            interval=50
        )
        
        plt.tight_layout()
        return fig, ani

# Example usage
if __name__ == "__main__":
    # Create a tanker spacecraft
    tanker = Tanker(EARTH_RADIUS, 0, 0) # Initial position at R, angle 0 (will be updated by launchpad)
    
    # Create simulation
    sim = SimulateMission(EARTH_RADIUS, tanker)
    
    # Add launch pads
    sim.add_launch_pad(LaunchPad(EARTH_RADIUS, 0))
    sim.add_launch_pad(LaunchPad(EARTH_RADIUS, np.pi/4))
    sim.add_launch_pad(LaunchPad(EARTH_RADIUS, np.pi/2))
    
    # Add orbits with more separation
    low_orbit = sim.add_orbit(EARTH_RADIUS + 500)  # Low orbit at 500km altitude
    medium_orbit = sim.add_orbit(EARTH_RADIUS + 2000) # Medium orbit at 2000km altitude
    high_orbit = sim.add_orbit(EARTH_RADIUS + 5000) # High orbit at 5000km altitude

    # Calculate orbital speeds based on radius and base factor
    base_speed = BASE_ORBITAL_SPEED_FACTOR
    # Reference speed is now calculated for the new low_orbit radius
    low_speed = np.sqrt(MU / low_orbit.radius) * base_speed # Corrected speed calculation
    medium_speed = np.sqrt(MU / medium_orbit.radius) * base_speed # Corrected speed calculation
    high_speed = np.sqrt(MU / high_orbit.radius) * base_speed # Corrected speed calculation

    print(f"Calculated Speeds: Low={low_speed:.6f}, Medium={medium_speed:.6f}, High={high_speed:.6f}")

    # Add satellites to orbits
    for i in range(3):
        angle = i * 2 * np.pi / 3
        sim.add_satellite(low_orbit, angle, low_speed)  # Use calculated low speed

    for i in range(2):
        angle = i * np.pi
        sim.add_satellite(medium_orbit, angle, medium_speed)  # Use calculated medium speed

    for i in range(1):
        sim.add_satellite(high_orbit, 0, high_speed)  # Use calculated high speed

    # Run simulation
    sim.simulate_mission()

    fig, ani = sim.visualize()
    plt.show()
