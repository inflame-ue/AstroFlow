import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from matplotlib.patches import Wedge
import time

EARTH_RADIUS = 6378.137  # km
# BASE_ORBITAL_SPEED_FACTOR = 0.001 # Reduced speed factor
BASE_ORBITAL_SPEED_FACTOR = 0.02 # Increased speed factor
LOWEST_ORBIT_RADIUS = EARTH_RADIUS + 200 # Reference radius for speed calculation
MU = 398600.4418  # Earth's gravitational parameter (km³/s²). Adjust units as needed.

# --- Fuel Estimation Constants (Highly Simplified) ---
FUEL_MASS_PER_DELTA_V_KG_PER_KMS = 1500.0 # kg fuel / (km/s Delta-V)
FUEL_DENSITY_KG_PER_LITER = 1.0        # kg / L (e.g., similar to water)
# ----------------------------------------------------

class Orbit:
    def __init__(self, radius: float, inclination: float = 0):
        self.radius = radius
        self.satellites = []
        self.shuttles = []
        self.inclination = inclination

class LaunchPad:
    def __init__(self, radius: float, angle: float):
        self.position = radius
        self.angle = angle

class SpaceCraft:
    def __init__(self, radius: float, angle: float, velocity: float):
        self.radius = radius
        self.angle = angle
        # self.trajectory = [] # Trajectory will be managed by SimulateMission
        self.speed = velocity # Represents ANGULAR speed in rad/s (physical units)
        self.visible = True
        self.active = True

    def update(self, time_step): # time_step is in physical seconds
        # Only update if speed is non-zero to avoid drift for stationary objects
        if self.speed != 0 and time_step > 0:
            self.angle += self.speed * time_step # angle = omega * dt
            self.angle %= (2 * np.pi) # Keep angle within [0, 2*pi]
        # Trajectory points are generated by simulation steps, not here directly for tanker
        # return self.position() # Return new position

    def predict(self, time): # time is in physical seconds
        future_angle = self.angle + self.speed * time
        future_angle %= (2 * np.pi)
        return (self.radius * np.cos(future_angle), self.radius * np.sin(future_angle))

    def position(self):
        return (self.radius * np.cos(self.angle), self.radius * np.sin(self.angle))

class Satellite(SpaceCraft):
    def __init__(self, radius: float, angle: float, velocity: float):
        super().__init__(radius, angle, velocity)
        self.initial_angle = angle  # Store angle at mission start
        self.id = f"Sat-{int(radius)}-{angle:.2f}"

class Shuttle(SpaceCraft):
    def __init__(self, radius: float, angle: float, velocity: float):
        super().__init__(radius, angle, velocity)
        self.deployed = False
        self.id = f"Shuttle-{int(radius)}-{angle:.2f}"
        self.intercepted = False
        self.initial_angle: float | None = None # Angle at deployment
        self.deployment_time: float | None = None # Mission time at deployment
        self.recovery_time: float | None = None # Mission time at recovery

class Tanker(SpaceCraft):
    def __init__(self, radius: float, angle: float, velocity: float = 0, fuel: float = 1000.0):
        super().__init__(radius, angle, velocity)
        self.mode = "launch"  # launch, orbit, transfer, return
        self.fuel = fuel
        self.shuttles_deployed = []
        self.shuttles_recovered = []
        self.current_target = None
        # self.transfer_orbit = None # Transfer details managed by SimulateMission
        self.outbound = True  # True for outbound, False for return mission
        self.mission_events = []

    def add_event(self, mission_time, event_description):
        self.mission_events.append((mission_time, event_description))
        print(f"T+{mission_time:.2f}: {event_description}")

class HohmannTransfer:
    def __init__(self, r1, r2):
        self.r1 = r1
        self.r2 = r2
        # Check for identical radii, which implies zero transfer time and potential division by zero
        if abs(r1 - r2) < 1e-6: # Use a small tolerance
            self.a = r1
            self.transfer_time = 0.0
            self.e = 0.0 # Eccentricity is 0 for circle-to-circle (no actual transfer)
        else:
            self.a = (r1 + r2) / 2
            self.e = abs(r2 - r1) / (r1 + r2)
            self.MU = MU  # Use the global MU constant
            # Transfer time (half-period) using Kepler's Third Law
            # Ensure a is positive before sqrt
            if self.a <= 0:
                 raise ValueError(f"Invalid semi-major axis {self.a} for transfer from {r1} to {r2}")
            self.transfer_time = np.pi * np.sqrt(self.a**3 / self.MU)  # Corrected with MU

        # Velocity calculations using MU (can be calculated even if r1=r2, but deltas would be 0)
        self.v1 = np.sqrt(self.MU / r1) if r1 > 0 else 0 # Initial circular velocity
        self.v2 = np.sqrt(self.MU / r2) if r2 > 0 else 0 # Target circular velocity
        if self.a > 0: # Check semi-major axis validity before calculating transfer velocities
             self.v_trans_1 = np.sqrt(self.MU * (2/r1 - 1/self.a)) if r1 > 0 else 0 # Transfer orbit at r1
             self.v_trans_2 = np.sqrt(self.MU * (2/r2 - 1/self.a)) if r2 > 0 else 0 # Transfer orbit at r2
        else: # Handle case where a might be non-positive (e.g., r1=r2=0)
             self.v_trans_1 = 0
             self.v_trans_2 = 0


class SimulateMission:
    def __init__(self, planet_radius: float, tanker: Tanker):
        self.planet_radius = planet_radius
        self.tanker = tanker
        self.launch_pads = []
        self.all_launch_pads = []  # Store all launch pads for visualization
        self.orbits = []
        self.satellites = []
        self.shuttles = []
        self.mission_clock = 0  # Mission time in arbitrary units
        self.events = []
        # self.transfer_trajectories = [] # Will use tanker_mission_trajectory
        self.tanker_mission_trajectory = [] # Stores (time, x, y) points for the entire mission
        self.initial_launch_angle = None # Store the angle of the launch pad used
        self.total_delta_v = 0.0 # Initialize total Delta-V (fuel proxy)
        self.launch_pad_efficiency = 1.0  # Efficiency factor for fuel calculation

    def add_launch_pad(self, launch_pad: LaunchPad):
        self.launch_pads.append(launch_pad)
        
    def add_all_launch_pads(self, launch_pads):
        """Store all launch pads for visualization"""
        self.all_launch_pads = launch_pads.copy()

    def add_orbit(self, radius: float, inclination: float = 0):
        orbit = Orbit(radius, inclination)
        self.orbits.append(orbit)
        return orbit

    def add_satellite(self, orbit: Orbit, angle: float, speed_factor: float = 1.0): # speed_factor is now optional/unused internally
        # Calculate physical angular speed (rad/s)
        if orbit.radius <= 0:
             speed = 0.0
        else:
             # omega = v/r = sqrt(MU/r) / r
             speed = np.sqrt(MU / orbit.radius) / orbit.radius
        # Note: speed_factor is ignored here as we use physical units now.
        # If different relative speeds were desired, factor could be applied here.

        satellite = Satellite(orbit.radius, angle, speed)
        orbit.satellites.append(satellite)
        self.satellites.append(satellite)
        return satellite

    def deploy_shuttle(self, orbit: Orbit, angle: float, speed: float): # speed is angular rad/s
        shuttle = Shuttle(orbit.radius, angle, speed)
        orbit.shuttles.append(shuttle)
        self.shuttles.append(shuttle)
        self.tanker.shuttles_deployed.append(shuttle)
        return shuttle

    def calculate_best_launch_pad(self):
        # Find the launch pad that requires the least angular adjustment relative to initial target
        if not self.launch_pads:
            raise ValueError("No launch pads available")
        if not self.orbits or not self.orbits[0].satellites:
             # Default to first pad if no orbits/satellites exist yet for targeting
             return self.launch_pads[0], 0

        # Simple selection: find pad closest in angle to the first satellite in the lowest orbit
        # (A more realistic model would involve launch windows based on orbital mechanics)
        target_sat = self.orbits[0].satellites[0]
        best_pad = self.launch_pads[0]
        min_angle_diff = float('inf')

        for pad in self.launch_pads:
            # Calculate angular difference (shortest path)
            angle_diff = abs(pad.angle - target_sat.angle) % (2 * np.pi)
            angle_diff = min(angle_diff, 2 * np.pi - angle_diff)
            if angle_diff < min_angle_diff:
                min_angle_diff = angle_diff
                best_pad = pad

        # Add launch pad efficiency calculation based on the angle
        # This will create varying fuel efficiency for different launch pads
        launch_efficiency = 0.9 + 0.2 * (abs(best_pad.angle) % np.pi) / np.pi
        self.launch_pad_efficiency = launch_efficiency
        print(f"  Launch pad efficiency factor: {launch_efficiency:.2f}")
        
        # Placeholder fuel calculation (not used currently)
        fuel_needed = abs(self.orbits[0].radius - self.planet_radius) * 0.1

        return best_pad, fuel_needed

    def calculate_intercept_time(self, spacecraft1, spacecraft2):
        """Calculate time to intercept between two spacecraft in the same orbit (in seconds)"""
        if abs(spacecraft1.radius - spacecraft2.radius) > 1e-3: # Check if they are in same orbit
            return float('inf') # Cannot intercept if in different orbits this way

        # Speeds are now angular (rad/s)
        relative_speed = spacecraft1.speed - spacecraft2.speed
        if abs(relative_speed) < 1e-9: # Check for zero or near-zero relative speed
             # If angles are already aligned (within tolerance), intercept time is 0
             angle_diff = (spacecraft2.angle - spacecraft1.angle + 2 * np.pi) % (2 * np.pi)
             if abs(angle_diff) < 1e-6 or abs(angle_diff - 2 * np.pi) < 1e-6:
                 return 0.0
             else:
                 return float('inf') # Same speed, different angles, never intercept

        # Calculate angular difference (target angle - current angle)
        # We want the positive difference representing the angle spacecraft1 needs to gain/lose
        angle_diff = (spacecraft2.angle - spacecraft1.angle) % (2 * np.pi)

        # Time = Angle / Relative Angular Speed (result is in seconds)
        intercept_time = angle_diff / relative_speed

        # We need the *first* positive intercept time
        if intercept_time < -1e-9: # If time is negative, add one period of relative phase
             # Add angle corresponding to one relative revolution (2*pi)
             intercept_time = (angle_diff + 2*np.pi) / relative_speed

        # Final check for non-negative time
        return intercept_time if intercept_time >= -1e-9 else float('inf')


    def find_next_optimal_target(self, current_orbit_idx):
        """Find the next optimal satellite to intercept for direct rendezvous (wait time in seconds)""" # Updated docstring
        if current_orbit_idx >= len(self.orbits) - 1:
            # We're at the highest orbit already
            return None, None, float('inf')

        current_orbit = self.orbits[current_orbit_idx]
        next_orbit = self.orbits[current_orbit_idx + 1]
        best_target = None
        min_total_time = float('inf') # Minimize (wait_time + transfer_time)
        optimal_transfer = None
        optimal_wait_time = float('inf')

        # Calculate Hohmann transfer parameters
        # Ensure radii are different enough to warrant transfer calculation
        if abs(current_orbit.radius - next_orbit.radius) < 1e-3:
             print(f"Warning: Attempting Hohmann transfer between nearly identical orbits ({current_orbit.radius} -> {next_orbit.radius}). Skipping.")
             return None, None, float('inf')

        transfer = HohmannTransfer(current_orbit.radius, next_orbit.radius)
        if transfer.transfer_time < 1e-9: # Check if transfer is instantaneous (r1=r2)
             print(f"Warning: Zero transfer time calculated for {current_orbit.radius} -> {next_orbit.radius}. Skipping.")
             return None, None, float('inf') # Avoid division by zero later

        # Need tanker's current position accurately
        current_tanker_angle = self.tanker.angle % (2 * np.pi)
        current_tanker_speed = self.tanker.speed # Angular speed in rad/s

        if abs(current_tanker_speed) < 1e-9:
             print("Warning: Tanker angular speed is near zero. Cannot calculate wait time accurately.")
             return None, None, float('inf')

        for satellite in next_orbit.satellites:
            # Calculate current angular positions
            current_satellite_angle = satellite.angle % (2 * np.pi)
            satellite_speed = satellite.speed # Angular speed in rad/s

            # --- Rendezvous Logic ---
            # Calculate satellite's angle at the *end* of the Hohmann transfer (physical time)
            # We need to estimate the wait time first to calculate this accurately. This creates a dependency loop.
            # Let's iterate or use an approximation:
            # Approximation 1: Assume wait_time is 0 initially to estimate arrival angle.
            estimated_arrival_time = self.mission_clock + transfer.transfer_time
            satellite_angle_at_estimated_arrival = (satellite.angle + satellite_speed * transfer.transfer_time) % (2 * np.pi)

            # Tanker must arrive at satellite_angle_at_arrival.
            # Hohmann transfer covers pi radians.
            # Therefore, tanker must *depart* from:
            required_departure_angle = (satellite_angle_at_estimated_arrival - np.pi) % (2 * np.pi) # MODIFIED LINE

            # Calculate angle the tanker needs to travel in its current orbit to reach the departure angle
            angle_to_travel = (required_departure_angle - current_tanker_angle) % (2 * np.pi)

            # Calculate wait time (seconds) based on this departure angle
            wait_time = angle_to_travel / current_tanker_speed if abs(current_tanker_speed) > 1e-9 else float('inf')

            # Ensure wait time is positive (add orbital periods if negative)
            if wait_time < -1e-9: # Use tolerance
                orbit_period_phys = (2* np.pi) / abs(current_tanker_speed) if abs(current_tanker_speed) > 1e-9 else float('inf')
                if orbit_period_phys == float('inf'):
                     print("Warning: Cannot calculate orbit period for wait time adjustment (zero angular speed?).")
                     continue # Skip this target if period is infinite
                # Add periods until wait_time is positive
                num_periods_to_add = math.ceil(abs(wait_time) / orbit_period_phys)
                wait_time += num_periods_to_add * orbit_period_phys

            # Recalculate satellite arrival angle using the calculated wait_time for better accuracy
            satellite_angle_at_actual_arrival = (satellite.angle + satellite_speed * (wait_time + transfer.transfer_time)) % (2 * np.pi)
            required_departure_angle_refined = (satellite_angle_at_actual_arrival - np.pi) % (2 * np.pi)

            # Recalculate angle to travel and wait time based on refined departure angle
            angle_to_travel_refined = (required_departure_angle_refined - current_tanker_angle) % (2 * np.pi)
            wait_time_refined = angle_to_travel_refined / current_tanker_speed if abs(current_tanker_speed) > 1e-9 else float('inf')

            if wait_time_refined < -1e-9: # Ensure positive again after refinement
                 orbit_period_phys = (2* np.pi) / abs(current_tanker_speed) if abs(current_tanker_speed) > 1e-9 else float('inf')
                 if orbit_period_phys == float('inf'):
                      print("Warning: Cannot calculate orbit period for refined wait time adjustment.")
                      continue
                 num_periods_to_add = math.ceil(abs(wait_time_refined) / orbit_period_phys)
                 wait_time_refined += num_periods_to_add * orbit_period_phys

            # Ensure non-negative final wait time
            wait_time_final = max(0, wait_time_refined)

            # Calculate total time for this option (seconds)
            total_time = wait_time_final + transfer.transfer_time # Both are physical seconds

            # --- End Rendezvous Logic ---

            if total_time < min_total_time:
                min_total_time = total_time
                optimal_wait_time = wait_time_final
                best_target = satellite
                optimal_transfer = transfer

        # Ensure optimal_wait_time is non-negative after adjustments (redundant check, but safe)
        optimal_wait_time = max(0, optimal_wait_time) # wait_time is in seconds

        # Add a debug print for the chosen target and wait time
        if best_target:
             print(f"Debug: Optimal target {best_target.id}, Wait time: {optimal_wait_time:.2f}s, Transfer time: {optimal_transfer.transfer_time:.2f}s")

        return best_target, optimal_transfer, optimal_wait_time

    def find_next_shuttle_target(self, current_orbit_idx):
        """Find the next shuttle to intercept on return journey (wait time in seconds)"""
        if current_orbit_idx <= 0:
            # We're at the lowest orbit already
            return None, None, float('inf')

        current_orbit = self.orbits[current_orbit_idx]
        next_orbit = self.orbits[current_orbit_idx - 1] # Target lower orbit
        best_target = None
        min_total_time = float('inf') # Minimize (wait_time + transfer_time)
        optimal_transfer = None
        optimal_wait_time = float('inf')

        # Calculate Hohmann transfer parameters (Inward: r1 > r2)
        if abs(current_orbit.radius - next_orbit.radius) < 1e-3:
             print(f"Warning: Attempting Hohmann transfer between nearly identical orbits ({current_orbit.radius} -> {next_orbit.radius}). Skipping.")
             return None, None, float('inf')

        transfer = HohmannTransfer(current_orbit.radius, next_orbit.radius)
        if transfer.transfer_time < 1e-9:
             print(f"Warning: Zero transfer time calculated for {current_orbit.radius} -> {next_orbit.radius}. Skipping.")
             return None, None, float('inf')

        # Need tanker's current position accurately
        current_tanker_angle = self.tanker.angle % (2 * np.pi)
        current_tanker_speed = self.tanker.speed # Angular speed in rad/s

        if abs(current_tanker_speed) < 1e-9:
             print("Warning: Tanker angular speed is near zero. Cannot calculate wait time accurately.")
             return None, None, float('inf')

        for shuttle in next_orbit.shuttles:
            # Skip already recovered or inactive shuttles
            if shuttle in self.tanker.shuttles_recovered or not shuttle.deployed or shuttle.recovery_time is not None:
                 continue

            # Calculate current angular positions
            current_shuttle_angle = shuttle.angle % (2 * np.pi)
            shuttle_speed = shuttle.speed # Angular speed in rad/s

            # Calculate shuttle's angle at the *end* of the Hohmann transfer
            shuttle_angle_at_arrival = (current_shuttle_angle + shuttle_speed * transfer.transfer_time) % (2 * np.pi)

            # The tanker needs to *arrive* at the *same angle* as the shuttle *at arrival*.
            # Tanker arrival angle = shuttle_angle_at_arrival
            # The transfer itself covers pi radians (from tanker's perspective relative to center).
            # So, the tanker must *depart* from an angle pi radians *before* the target arrival angle.
            required_departure_angle = (shuttle_angle_at_arrival - np.pi) % (2 * np.pi)

            # Calculate angle the tanker needs to travel in its current orbit to reach the departure angle
            angle_to_travel = (required_departure_angle - current_tanker_angle) % (2 * np.pi)

            # Calculate wait time (seconds)
            wait_time = angle_to_travel / current_tanker_speed

            # Ensure wait time is positive
            if wait_time < -1e-9: # Use tolerance
                 orbit_period_phys = (2* np.pi) / abs(current_tanker_speed) if abs(current_tanker_speed) > 1e-9 else float('inf')
                 if orbit_period_phys == float('inf'):
                     print("Warning: Cannot calculate orbit period for wait time adjustment (zero angular speed?).")
                     continue
                 wait_time += orbit_period_phys

            # Calculate total time for this option (seconds)
            total_time = wait_time + transfer.transfer_time

            if total_time < min_total_time:
                min_total_time = total_time
                optimal_wait_time = wait_time
                best_target = shuttle
                optimal_transfer = transfer

        # Ensure optimal_wait_time is non-negative after adjustments
        optimal_wait_time = max(0, optimal_wait_time) # wait time in seconds

        return best_target, optimal_transfer, optimal_wait_time

    def execute_hohmann_transfer(self, transfer):
        """Executes a Hohmann transfer using Keplerian calculations (time in seconds)."""
        start_angle = self.tanker.angle % (2 * np.pi)
        start_radius = self.tanker.radius
        steps = 200 # Number of steps for trajectory calculation
        transfer_trajectory_points = []
        start_time = self.mission_clock # Now physical seconds

        # Add starting point
        start_pos_x = start_radius * np.cos(start_angle)
        start_pos_y = start_radius * np.sin(start_angle)
        transfer_trajectory_points.append((start_time, start_pos_x, start_pos_y))

        # Check for zero transfer time (e.g., r1 == r2)
        if transfer.transfer_time <= 1e-9:
            print("Debug: Zero transfer time, skipping transfer loop.")
            self.tanker.radius = transfer.r2
            # Set correct physical angular speed for the (unchanged) orbit
            self.tanker.speed = (np.sqrt(MU / self.tanker.radius) / self.tanker.radius) if self.tanker.radius > 0 else 0
            transfer_trajectory_points.append((self.mission_clock, start_pos_x, start_pos_y))
            return transfer_trajectory_points

        # Transfer parameters
        a = transfer.a
        e = transfer.e
        transfer_time_phys = transfer.transfer_time # Physical time in seconds

        # --- NO LONGER SCALE TIME ---
        # transfer_time_sim = transfer_time_phys / BASE_ORBITAL_SPEED_FACTOR # REMOVED
        phys_time_step = transfer_time_phys / steps # Time step is physical seconds
        # sim_time_step = transfer_time_sim / steps # REMOVED
        # ---------------------------------


        # Determine Angle of Periapsis (P) relative to inertial frame
        if transfer.r1 < transfer.r2:  # Outward transfer (starts at periapsis)
            angle_of_periapsis = start_angle
        else:  # Inward transfer (starts at apoapsis)
            angle_of_periapsis = (start_angle - np.pi) % (2 * np.pi) # Periapsis is 180deg behind start

        # Pre-calculate rotation matrix components
        cos_P = np.cos(angle_of_periapsis)
        sin_P = np.sin(angle_of_periapsis)
        # Pre-calculate a*sqrt(1-e^2)
        a_sqrt_1_minus_e2 = a * np.sqrt(1 - e**2) if (1 - e**2) >= 0 else 0 # Semi-minor axis related term

        for i in range(1, steps + 1):
            # Calculate physical time elapsed for this step to use in Kepler's equation
            # phys_time_step = transfer_time_phys / steps # Calculated above loop
            current_phys_time_in_transfer = i * phys_time_step

            # Calculate Mean Anomaly based on physical time elapsed in transfer
            # M goes 0 to pi for half-orbit transfer based on physical time fraction
            mean_anomaly = (current_phys_time_in_transfer / transfer_time_phys) * np.pi


            # Newton-Raphson solver for Eccentric Anomaly (E)
            E = mean_anomaly
            for _ in range(10):
                delta_E = (E - e * np.sin(E) - mean_anomaly) / (1 - e * np.cos(E))
                # Check for non-convergence or issues
                if not np.isfinite(delta_E):
                    print(f"Warning: delta_E calculation failed at M={mean_anomaly:.4f}. Using previous E.")
                    break # Use last valid E
                E -= delta_E
                if abs(delta_E) < 1e-7: # Convergence tolerance
                    break
            else: # If loop finishes without break (convergence)
                print(f"Warning: Eccentric Anomaly solver did not converge well for M={mean_anomaly:.4f}")


            # Calculate position in the orbital frame (x' towards periapsis)
            if transfer.r1 < transfer.r2: # Outward
                 x_prime = a * (np.cos(E) - e)
                 y_prime = a_sqrt_1_minus_e2 * np.sin(E)
            else: # Inward
                 x_prime = a * (-np.cos(E) - e)
                 y_prime = -a_sqrt_1_minus_e2 * np.sin(E)

            # Rotate orbital frame position to inertial frame
            pos_x = x_prime * cos_P - y_prime * sin_P
            pos_y = x_prime * sin_P + y_prime * cos_P

            # --- Update other objects using PHYSICAL time step ---
            # Time passes by phys_time_step (seconds) for *this segment* of the transfer
            for satellite in self.satellites:
                 if satellite.active:
                     satellite.update(phys_time_step) # Use physical time step
            for shuttle in self.shuttles:
                 if shuttle.active:
                     # Check status relative to mission clock (physical seconds)
                     is_deployed = shuttle.deployed and shuttle.deployment_time is not None and (self.mission_clock + phys_time_step) >= shuttle.deployment_time
                     is_not_yet_recovered = shuttle.recovery_time is None or (self.mission_clock + phys_time_step) < shuttle.recovery_time
                     if is_deployed and is_not_yet_recovered:
                         shuttle.update(phys_time_step) # Use physical time step
            # --- End update other objects ---

            # Advance mission clock *using physical time step*
            self.mission_clock += phys_time_step # mission_clock is now physical seconds

            # Append calculated inertial position with the time (physical seconds) at the END of this step
            transfer_trajectory_points.append((self.mission_clock, pos_x, pos_y))

            # Update tanker's internal state (radius/angle)
            self.tanker.radius = np.sqrt(pos_x**2 + pos_y**2)
            self.tanker.angle = np.arctan2(pos_y, pos_x) % (2 * np.pi)

        # Final state update after loop completion
        final_time, final_x, final_y = transfer_trajectory_points[-1]
        final_radius = np.sqrt(final_x**2 + final_y**2)
        final_angle = np.arctan2(final_y, final_x) % (2 * np.pi)

        # Ensure tanker object state matches calculated final state precisely
        self.tanker.radius = final_radius
        self.tanker.angle = final_angle


        # Verify final radius against target radius (debugging)
        radius_error = abs(final_radius - transfer.r2)
        if radius_error > 1.0: # Allow 1km tolerance
             print(f"Warning: Hohmann transfer final radius error: {radius_error:.2f} km. Target: {transfer.r2:.1f}, Achieved: {final_radius:.1f}")
             # Force tanker radius to target radius
             self.tanker.radius = transfer.r2
             # Recalculate final x,y based on forced radius and calculated angle
             final_x = self.tanker.radius * np.cos(final_angle)
             final_y = self.tanker.radius * np.sin(final_angle)
             # Update the last trajectory point
             transfer_trajectory_points[-1] = (final_time, final_x, final_y)
             print(f"  Forcing final radius to {transfer.r2:.1f} km.")


        # Set final speed to the physical angular speed for the new circular orbit
        self.tanker.speed = (np.sqrt(MU / self.tanker.radius) / self.tanker.radius) if self.tanker.radius > 0 else 0

        # --- Calculate Hohmann Transfer Delta-V (Fuel Proxy) ---
        if transfer.transfer_time > 1e-9: # Only calculate if it was a real transfer
            delta_v1 = abs(transfer.v_trans_1 - transfer.v1)
            delta_v2 = abs(transfer.v2 - transfer.v_trans_2)
            transfer_delta_v = delta_v1 + delta_v2
            self.total_delta_v += transfer_delta_v
            self.tanker.add_event(self.mission_clock, f"Hohmann transfer Delta-V: {transfer_delta_v:.3f} km/s ({delta_v1:.3f} + {delta_v2:.3f})")
        # --- End Delta-V Calculation ---

        return transfer_trajectory_points


    def simulate_launch(self, tanker: Tanker, target_orbit: Orbit, target_angle: float):
        """Simulate launch from planet to first orbit (time in seconds)"""
        # Start position on planet surface at chosen launch pad angle
        start_radius = self.planet_radius
        start_angle = tanker.angle # Angle set by best_launch_pad

        # Generate trajectory
        steps = 50
        final_radius = target_orbit.radius
        launch_trajectory_points = [] # Local list

        # Add initial position with current time
        start_time = self.mission_clock # physical seconds
        start_pos_x = start_radius * np.cos(start_angle)
        start_pos_y = start_radius * np.sin(start_angle)
        launch_trajectory_points.append((start_time, start_pos_x, start_pos_y))

        # Estimate total launch time (now in physical seconds)
        estimated_launch_duration = 600.0 # e.g., 10 minutes = 600 seconds (adjust as needed)

        for i in range(1, steps + 1):
            t = i / steps
            # Interpolate radius from planet radius to orbit radius
            current_radius = start_radius + t * (final_radius - start_radius)

            # Interpolate angle from launch angle towards target angle in orbit
            # Ensure shortest path interpolation for angle
            delta_angle = target_angle - start_angle
            delta_angle = (delta_angle + np.pi) % (2 * np.pi) - np.pi # Normalize to [-pi, pi]
            current_angle = (start_angle + t * delta_angle) % (2 * np.pi)

            x = current_radius * np.cos(current_angle)
            y = current_radius * np.sin(current_angle)

            # --- Update other objects using physical time step ---
            time_in_this_step = estimated_launch_duration / steps # physical seconds
            for satellite in self.satellites:
                 if satellite.active:
                     satellite.update(time_in_this_step)
            for shuttle in self.shuttles:
                 if shuttle.active:
                     # Check deployment/recovery status relative to the *end* of this step time (physical seconds)
                     is_deployed = shuttle.deployed and shuttle.deployment_time is not None and (self.mission_clock + time_in_this_step) >= shuttle.deployment_time
                     is_not_yet_recovered = shuttle.recovery_time is None or (self.mission_clock + time_in_this_step) < shuttle.recovery_time
                     if is_deployed and is_not_yet_recovered:
                          shuttle.update(time_in_this_step)
            # --- End update other objects ---

            # Update mission time *after* updates (physical seconds)
            self.mission_clock += time_in_this_step

            # --- Add trajectory point for this step ---
            launch_trajectory_points.append((self.mission_clock, x, y))

        # Final state update
        tanker.radius = final_radius
        tanker.angle = target_angle % (2 * np.pi)

        # Set tanker speed to physical angular velocity (rad/s)
        tanker.speed = (np.sqrt(MU / tanker.radius) / tanker.radius) if tanker.radius > 0 else 0

        # --- Calculate Launch Delta-V (Fuel Proxy) ---
        if tanker.radius > 0:
            v_orbit = np.sqrt(MU / tanker.radius) # Circular orbit speed (km/s)
            launch_delta_v = v_orbit # Delta-V from surface (0 speed) to orbit speed
            self.total_delta_v += launch_delta_v
            tanker.add_event(self.mission_clock, f"Launch maneuver Delta-V: {launch_delta_v:.3f} km/s")
        # --- End Delta-V Calculation ---

        # Add mission event (time is physical seconds)
        tanker.add_event(self.mission_clock, f"Launched to orbit {final_radius:.1f} km at angle {target_angle:.2f} rad")

        # --- Ensure last trajectory point exactly matches final state ---
        final_pos = tanker.position()
        if launch_trajectory_points: # Check list not empty
             # Overwrite the last calculated point with the precise final state
             launch_trajectory_points[-1] = (self.mission_clock, final_pos[0], final_pos[1])
        else: # Should not happen with steps > 0, but safety check
             launch_trajectory_points.append((self.mission_clock, final_pos[0], final_pos[1]))


        return launch_trajectory_points # Return points

    def simulate_reentry(self, tanker: Tanker, target_landing_angle: float):
        """Simulate reentry from lowest orbit to planet surface (time in seconds)"""
        # Start position in orbit
        start_radius = tanker.radius
        start_angle = tanker.angle % (2 * np.pi)
        target_landing_angle %= (2 * np.pi)

        # Generate trajectory
        steps = 100 # Increased steps for smoother curve
        reentry_trajectory_points = [] # Local list

        # Add starting point
        start_time = self.mission_clock # physical seconds
        start_pos = tanker.position()
        reentry_trajectory_points.append((start_time, start_pos[0], start_pos[1]))

        # Estimate total reentry time (physical seconds)
        estimated_reentry_duration = 1200.0 # Reset duration (e.g., 20 minutes) - adjust if needed

        # --- ANGLE LOGIC: Simple shortest path interpolation --- 
        # Calculate the shortest angle difference between start and target
        delta_angle = target_landing_angle - start_angle
        delta_angle = (delta_angle + np.pi) % (2 * np.pi) - np.pi # Normalize to [-pi, pi]
        # --- END ANGLE LOGIC ---


        for i in range(1, steps + 1):
            t = i / steps
            # Interpolate radius from orbit to planet
            current_radius = start_radius - t * (start_radius - self.planet_radius)

            # Interpolate angle using the simple shortest path delta
            current_angle = (start_angle + t * delta_angle) % (2 * np.pi) # Use normalized delta_angle

            x = current_radius * np.cos(current_angle)
            y = current_radius * np.sin(current_angle)

            # --- Update other objects using physical time step ---
            time_in_this_step = estimated_reentry_duration / steps # physical seconds
            for satellite in self.satellites:
                 if satellite.active:
                     satellite.update(time_in_this_step)
            for shuttle in self.shuttles:
                  if shuttle.active:
                      is_deployed = shuttle.deployed and shuttle.deployment_time is not None and (self.mission_clock + time_in_this_step) >= shuttle.deployment_time
                      is_not_yet_recovered = shuttle.recovery_time is None or (self.mission_clock + time_in_this_step) < shuttle.recovery_time
                      if is_deployed and is_not_yet_recovered:
                           shuttle.update(time_in_this_step)
            # --- End update other objects ---

            # Update mission time *after* updates (physical seconds)
            self.mission_clock += time_in_this_step

            # --- Add trajectory point for this step ---
            reentry_trajectory_points.append((self.mission_clock, x, y))

        # Update tanker final position (landed)
        tanker.radius = self.planet_radius
        # Ensure final angle is exactly the target landing angle, overriding calculation drift
        tanker.angle = target_landing_angle
        tanker.speed = 0 # Landed
        tanker.active = False # Tanker mission ends on landing

        # --- Calculate Reentry Delta-V (Fuel Proxy) ---
        if start_radius > 0:
            v_orbit = np.sqrt(MU / start_radius) # Circular orbit speed before reentry (km/s)
            reentry_delta_v = v_orbit # Delta-V to decelerate from orbit speed to (near) zero
            self.total_delta_v += reentry_delta_v
            tanker.add_event(self.mission_clock, f"Reentry maneuver Delta-V: {reentry_delta_v:.3f} km/s")
        # --- End Delta-V Calculation ---

        # Add mission event (time is physical seconds)
        tanker.add_event(self.mission_clock, f"Successful reentry and landing at angle {target_landing_angle:.2f} rad")

        # --- Ensure last trajectory point exactly matches final state ---
        final_pos = tanker.position()
        if reentry_trajectory_points:
             reentry_trajectory_points[-1] = (self.mission_clock, final_pos[0], final_pos[1])
        else:
             reentry_trajectory_points.append((self.mission_clock, final_pos[0], final_pos[1]))

        return reentry_trajectory_points # Return points

    def deploy_shuttle_to_orbit(self, orbit: Orbit):
        """Deploy a shuttle to the current orbit (speed is rad/s)"""
        # Shuttle speed should match the orbital speed magnitude for that radius, but opposite direction
        if orbit.radius <= 0:
             orbital_angular_speed_magnitude = 0.0
        else:
             # omega = v/r = sqrt(MU/r) / r
             orbital_angular_speed_magnitude = np.sqrt(MU / orbit.radius) / orbit.radius

        deployment_angle = self.tanker.angle
        deployment_time = self.mission_clock # physical seconds

        # Deploy shuttle moving in the opposite angular direction
        shuttle = self.deploy_shuttle(
            orbit,
            deployment_angle,
            -orbital_angular_speed_magnitude # Opposite angular speed (rad/s)
        )

        # Store deployment info (time is physical seconds)
        shuttle.initial_angle = deployment_angle
        shuttle.deployment_time = deployment_time
        shuttle.deployed = True

        # Add mission event (time is physical seconds)
        self.tanker.add_event(
            self.mission_clock,
            f"Deployed shuttle {shuttle.id} in orbit {orbit.radius:.1f} km"
        )

        return shuttle

    def recover_shuttle(self, shuttle: Shuttle):
        """Recover a shuttle during rendezvous (time is physical seconds)"""
        # Check if shuttle is valid and deployed
        if shuttle not in self.tanker.shuttles_deployed or not shuttle.deployed:
            print(f"Warning: Attempted to recover shuttle {shuttle.id} which was not deployed or already recovered.")
            return False

        # Basic proximity check (optional but good practice)
        radius_diff = abs(self.tanker.radius - shuttle.radius)
        angle_diff = abs(self.tanker.angle - shuttle.angle) % (2*np.pi)
        angle_diff = min(angle_diff, 2*np.pi - angle_diff)

        if radius_diff > 10.0 or angle_diff > np.deg2rad(5): # Tolerances (e.g., 10km, 5 degrees)
            print(f"Warning: Tanker not close enough to recover shuttle {shuttle.id}. R diff: {radius_diff:.1f}, Angle diff: {np.rad2deg(angle_diff):.1f} deg")
            # Optionally, proceed anyway or return False
            # return False # Stricter check

        print(f"Recovering shuttle {shuttle.id}...")
        shuttle.intercepted = True
        shuttle.active = False
        shuttle.recovery_time = self.mission_clock # Record recovery time (physical seconds)
        self.tanker.shuttles_recovered.append(shuttle)

        # Add mission event (time is physical seconds)
        self.tanker.add_event(
            self.mission_clock,
            f"Recovered shuttle {shuttle.id} from orbit {shuttle.radius:.1f} km"
        )

        return True

    def wait_in_orbit(self, wait_time): # wait_time is physical seconds
        """Wait in current orbit for the specified time (seconds), updating all objects."""
        if wait_time <= 1e-9:
            return []

        start_angle = self.tanker.angle
        start_radius = self.tanker.radius

        # Determine number of steps for trajectory based on wait time (seconds)
        time_resolution = 5.0 # Sample point every 5 physical seconds (adjust as needed)
        # Speed factor based on physical angular speed (rad/s)
        speed_factor_steps = abs(self.tanker.speed) * wait_time * 10 # More steps for larger angle swept
        steps = max(1, int(wait_time / time_resolution + speed_factor_steps))

        # CAP THE STEPS
        max_wait_steps = 1000
        steps = min(steps, max_wait_steps)

        actual_time_step = wait_time / steps # Physical seconds per step

        wait_trajectory_points = []
        start_time = self.mission_clock # physical seconds
        start_pos = self.tanker.position()
        wait_trajectory_points.append((start_time, start_pos[0], start_pos[1]))

        for i in range(steps):
            # Update satellites and active shuttles first for this time step (physical seconds)
            for satellite in self.satellites:
                if satellite.active:
                    satellite.update(actual_time_step)

            for shuttle in self.shuttles:
                 if shuttle.active:
                     is_deployed = shuttle.deployed and shuttle.deployment_time is not None and (self.mission_clock + actual_time_step) >= shuttle.deployment_time
                     is_not_yet_recovered = shuttle.recovery_time is None or (self.mission_clock + actual_time_step) < shuttle.recovery_time
                     if is_deployed and is_not_yet_recovered:
                         shuttle.update(actual_time_step)


            # Update tanker position for this step (uses physical angular speed and physical time step)
            self.tanker.update(actual_time_step)

            # Advance mission clock (physical seconds)
            self.mission_clock += actual_time_step
            current_pos = self.tanker.position()
            # Ensure radius hasn't drifted (should be circular wait)
            current_pos_x = start_radius * np.cos(self.tanker.angle)
            current_pos_y = start_radius * np.sin(self.tanker.angle)
            wait_trajectory_points.append((self.mission_clock, current_pos_x, current_pos_y))

        # Add event log entry if wait was significant
        current_orbit_idx = self.find_current_orbit_index()
        if wait_time > 1.0: # Log waits longer than 1 second
            self.tanker.add_event(
                self.mission_clock,
                f"Waited in orbit {self.orbit_index_to_string(current_orbit_idx)} for {wait_time:.2f} seconds"
            )

        # Ensure final tanker state radius is correct after wait
        self.tanker.radius = start_radius

        return wait_trajectory_points

    def find_current_orbit_index(self):
        """Find the index of the orbit the tanker is currently in."""
        # Find the orbit with the closest radius to the tanker's current radius
        min_diff = float('inf')
        closest_idx = -1
        for idx, orbit in enumerate(self.orbits):
            diff = abs(self.tanker.radius - orbit.radius)
            if diff < min_diff:
                min_diff = diff
                closest_idx = idx

        # Return index only if difference is within a tolerance (e.g., 5 km)
        if min_diff < 5.0:
            return closest_idx
        else:
            # print(f"Debug: Tanker radius {self.tanker.radius:.1f} not close enough to any defined orbit (min diff: {min_diff:.1f}).")
            return -1 # Not considered to be 'in' a defined orbit

    def orbit_index_to_string(self, index):
        if 0 <= index < len(self.orbits):
            return f"{self.orbits[index].radius:.1f} km (Index {index})"
        elif index == -1:
            return f"Transfer Orbit (R={self.tanker.radius:.1f} km)"
        return "Unknown Orbit"

    def get_total_fuel_liters(self):
        """Calculate estimated fuel volume in liters based on total Delta-V."""
        if FUEL_DENSITY_KG_PER_LITER <= 0:
            print("Warning: Fuel density is non-positive, cannot calculate volume.")
            return 0.0
        # Apply the launch pad efficiency factor to make fuel usage different
        fuel_mass_kg = self.total_delta_v * FUEL_MASS_PER_DELTA_V_KG_PER_KMS * self.launch_pad_efficiency
        fuel_liters = fuel_mass_kg / FUEL_DENSITY_KG_PER_LITER
        return fuel_liters

    def simulate_mission(self):
        """Simulate the entire mission with multiple transfers and shuttle deployments"""
        # Ensure orbits are sorted by radius for consistent indexing
        self.orbits.sort(key=lambda x: x.radius)

        if not self.orbits:
            print("Error: No orbits defined for the mission.")
            return
        if not self.launch_pads:
            print("Error: No launch pads defined.")
            return

        # Get best launch pad (simple angle-based selection for now)
        best_pad, _ = self.calculate_best_launch_pad()
        self.tanker.angle = best_pad.angle
        self.initial_launch_angle = best_pad.angle # Store for return landing
        self.tanker.radius = self.planet_radius # Ensure tanker starts on surface
        self.tanker.speed = 0 # Start stationary
        self.tanker.active = True # Ensure tanker is active at start

        # Add starting point to trajectory
        start_pos = self.tanker.position()
        self.tanker_mission_trajectory.append((0.0, start_pos[0], start_pos[1]))
        self.tanker.add_event(0.0, f"Mission start at Launch Pad angle {self.initial_launch_angle:.2f} rad")

        # --- OUTBOUND MISSION (DEPLOYMENT PHASE) ---
        self.tanker.outbound = True
        print("\n=== Starting Outbound Phase ===")

        # Target the lowest orbit first
        lowest_orbit = self.orbits[0]

        # --- Launch Phase ---
        # For simplicity, launch immediately towards the angle 0 in the first orbit
        # A more complex model would calculate launch windows for rendezvous
        # --- Rendezvous Launch Calculation ---
        estimated_launch_duration = 600.0 # Use the same estimate as in simulate_launch
        launch_target_angle = 0.0 # Default target angle

        # Select a target satellite (e.g., the first one in the lowest orbit)
        target_sat_for_launch = None
        if lowest_orbit.satellites:
            target_sat_for_launch = lowest_orbit.satellites[0]
            # Predict satellite's angle after estimated launch duration
            predicted_sat_angle = (target_sat_for_launch.angle + target_sat_for_launch.speed * estimated_launch_duration) % (2 * np.pi)
            launch_target_angle = predicted_sat_angle # Target this angle
            print(f"Calculating launch trajectory to orbit {lowest_orbit.radius:.1f} km...")
            print(f"  Targeting rendezvous with {target_sat_for_launch.id}, predicted angle: {launch_target_angle:.2f} rad")
        else:
            print(f"Calculating launch trajectory to orbit {lowest_orbit.radius:.1f} km, target angle {launch_target_angle:.2f} rad (No satellites in orbit for rendezvous).")
        # --- End Rendezvous Launch Calculation ---

        launch_traj = self.simulate_launch(self.tanker, lowest_orbit, launch_target_angle)
        self.tanker_mission_trajectory.extend(launch_traj)

        # Check if launch was successful (tanker is now in orbit)
        current_orbit_idx_after_launch = self.find_current_orbit_index()
        if current_orbit_idx_after_launch != 0:
             print("Error: Launch simulation failed to reach the first orbit.")
             # Optional: Add actual final angle vs target angle check
             if target_sat_for_launch:
                  actual_angle = self.tanker.angle
                  actual_sat_angle = (target_sat_for_launch.angle + target_sat_for_launch.speed * (self.mission_clock)) % (2 * np.pi) # Use actual mission clock time
                  angle_diff = abs(actual_angle - actual_sat_angle)
                  angle_diff = min(angle_diff, 2*np.pi - angle_diff)
                  print(f"  Post-Launch Rendezvous Check: Tanker Angle={actual_angle:.2f}, Sat Angle={actual_sat_angle:.2f}, Diff={np.rad2deg(angle_diff):.1f} deg")
             return # Stop mission if launch fails

        print(f"Successfully arrived in orbit {self.orbit_index_to_string(0)}.")
        # Optional: Check actual angle vs target angle even on success
        if target_sat_for_launch:
             actual_angle = self.tanker.angle
             actual_sat_angle = (target_sat_for_launch.initial_angle + target_sat_for_launch.speed * self.mission_clock) % (2 * np.pi) # Use satellite initial angle + total time
             angle_diff = abs(actual_angle - actual_sat_angle) % (2 * np.pi)
             angle_diff = min(angle_diff, 2*np.pi - angle_diff)
             print(f"  Post-Launch Rendezvous Check: Tanker Angle={actual_angle:.2f}, Sat Angle={actual_sat_angle:.2f}, Diff={np.rad2deg(angle_diff):.1f} deg")


        # Deploy first shuttle in the lowest orbit
        print(f"Deploying shuttle in orbit {self.orbit_index_to_string(0)}...")
        self.deploy_shuttle_to_orbit(lowest_orbit)

        # --- Orbital Transfers (Outbound) ---
        current_orbit_idx = 0 # Start from orbit 0
        while current_orbit_idx < len(self.orbits) - 1:
            print(f"\nPlanning transfer from orbit {self.orbit_index_to_string(current_orbit_idx)}...")

            # Find next optimal target satellite in the next higher orbit
            next_target, transfer, wait_time = self.find_next_optimal_target(current_orbit_idx)

            if next_target and transfer:
                print(f"  Targeting satellite {next_target.id} in orbit {self.orbit_index_to_string(current_orbit_idx + 1)}")
                print(f"  Calculated optimal wait time: {wait_time:.2f}")

                # Wait in current orbit if needed
                if wait_time > 1e-3: # Wait if time is non-negligible
                    wait_traj = self.wait_in_orbit(wait_time)
                    self.tanker_mission_trajectory.extend(wait_traj)

                # Execute Hohmann transfer
                self.tanker.add_event(
                    self.mission_clock,
                    f"Beginning transfer from orbit {self.orbit_index_to_string(current_orbit_idx)} to orbit {self.orbit_index_to_string(current_orbit_idx + 1)}"
                )
                transfer_traj = self.execute_hohmann_transfer(transfer)
                self.tanker_mission_trajectory.extend(transfer_traj)

                # Update current orbit index AFTER successful transfer
                current_orbit_idx += 1
                print(f"  Completed transfer. Now in orbit {self.orbit_index_to_string(current_orbit_idx)}.")

                # Check if transfer was successful (check tanker radius)
                if self.find_current_orbit_index() != current_orbit_idx:
                     print(f"Error: Transfer failed to reach orbit index {current_orbit_idx}. Current index: {self.find_current_orbit_index()}")
                     # Attempt to recover by forcing state? Or abort?
                     # Forcing state:
                     self.tanker.radius = self.orbits[current_orbit_idx].radius
                     self.tanker.speed = (np.sqrt(MU / self.tanker.radius) / self.tanker.radius) if self.tanker.radius > 0 else 0
                     print(f"  Forcing tanker state to orbit {current_orbit_idx}.")
                     # Add a point to trajectory reflecting the forced state
                     forced_pos = self.tanker.position()
                     self.tanker_mission_trajectory.append((self.mission_clock, forced_pos[0], forced_pos[1]))
                     # Continue cautiously

                # Deploy shuttle in the new orbit
                print(f"Deploying shuttle in orbit {self.orbit_index_to_string(current_orbit_idx)}...")
                self.deploy_shuttle_to_orbit(self.orbits[current_orbit_idx])

            else:
                # No valid target found or transfer not possible
                print(f"  No optimal satellite target found or transfer not possible from orbit {self.orbit_index_to_string(current_orbit_idx)}. Ending outbound transfers.")
                break # Exit the while loop for outbound transfers

        print("\n=== Outbound Phase Complete ===")

        # --- HIGHEST ORBIT WAIT & RECOVERY ---
        if current_orbit_idx == len(self.orbits) - 1:
            highest_orbit = self.orbits[current_orbit_idx]
            # Find the shuttle just deployed in this orbit
            highest_orbit_shuttle = None
            for s in highest_orbit.shuttles:
                if s in self.tanker.shuttles_deployed and s not in self.tanker.shuttles_recovered:
                    highest_orbit_shuttle = s
                    break

            if highest_orbit_shuttle and abs(highest_orbit_shuttle.speed) > 1e-9:
                print(f"\n--- Waiting in highest orbit ({self.orbit_index_to_string(current_orbit_idx)}) for shuttle rendezvous ---")
                # Shuttle moves in opposite direction, rendezvous should be after half period
                half_period_wait = np.pi / abs(highest_orbit_shuttle.speed) # Physical seconds
                self.tanker.add_event(
                    self.mission_clock,
                    f"Waiting {half_period_wait:.2f}s in highest orbit for shuttle {highest_orbit_shuttle.id}"
                )
                wait_traj = self.wait_in_orbit(half_period_wait)
                self.tanker_mission_trajectory.extend(wait_traj)

                print(f"Attempting recovery of shuttle {highest_orbit_shuttle.id} in highest orbit...")
                self.recover_shuttle(highest_orbit_shuttle)
            elif highest_orbit_shuttle:
                 print(f"Warning: Cannot calculate wait time for shuttle {highest_orbit_shuttle.id} in highest orbit (zero speed?). Skipping wait.")
            else:
                 print("Warning: Could not find shuttle deployed in the highest orbit to wait for.")

        else:
            print(f"Warning: Outbound phase ended unexpectedly before reaching the highest orbit (Index: {current_orbit_idx}). Skipping highest orbit wait.")


        # --- RETURN MISSION (RECOVERY PHASE) ---
        print("\n=== Starting Return Phase (Descent and Recovery) ===")
        self.tanker.outbound = False
        self.tanker.add_event(
            self.mission_clock,
            "Beginning return mission phase - descending and recovering shuttles"
        )

        # Start descent from the current orbit (should be highest)
        # The loop iterates while current_orbit_idx > 0, handling transfers to orbits [N-1 .. 1]
        while current_orbit_idx > 0:
            print(f"\nPlanning return transfer from orbit {self.orbit_index_to_string(current_orbit_idx)} to orbit {self.orbit_index_to_string(current_orbit_idx - 1)}...")

            # Find next shuttle to recover in the next lower orbit
            next_shuttle, transfer, wait_time = self.find_next_shuttle_target(current_orbit_idx)

            if next_shuttle and transfer:
                # --- Perform Wait, Transfer, Recover sequence ---
                print(f"  Targeting shuttle {next_shuttle.id} in orbit {self.orbit_index_to_string(current_orbit_idx - 1)}")
                print(f"  Calculated optimal wait time in current orbit: {wait_time:.2f}s")

                # 1. Wait in current (higher) orbit if needed
                if wait_time > 1e-3:
                    wait_traj = self.wait_in_orbit(wait_time)
                    self.tanker_mission_trajectory.extend(wait_traj)

                # 2. Execute Hohmann transfer (inward)
                self.tanker.add_event(
                    self.mission_clock,
                    f"Beginning transfer from orbit {self.orbit_index_to_string(current_orbit_idx)} to recover shuttle in orbit {self.orbit_index_to_string(current_orbit_idx - 1)}"
                )
                transfer_traj = self.execute_hohmann_transfer(transfer)
                self.tanker_mission_trajectory.extend(transfer_traj)

                # 3. Update current orbit index AFTER successful transfer
                current_orbit_idx -= 1
                print(f"  Completed transfer. Now in orbit {self.orbit_index_to_string(current_orbit_idx)}.")

                 # 4. Verify transfer success (check tanker radius)
                if self.find_current_orbit_index() != current_orbit_idx:
                     print(f"Error: Return transfer failed to reach target orbit index {current_orbit_idx}. Current index: {self.find_current_orbit_index()}")
                     # Attempt to force state
                     self.tanker.radius = self.orbits[current_orbit_idx].radius
                     self.tanker.speed = (np.sqrt(MU / self.tanker.radius) / self.tanker.radius) if self.tanker.radius > 0 else 0
                     print(f"  Forcing tanker state to orbit {current_orbit_idx}.")
                     forced_pos = self.tanker.position()
                     self.tanker_mission_trajectory.append((self.mission_clock, forced_pos[0], forced_pos[1]))
                     # Continue cautiously

                # 5. Calculate remaining intercept time in the target orbit
                print(f"Calculating final intercept wait time in orbit {self.orbit_index_to_string(current_orbit_idx)} for {next_shuttle.id}...")
                intercept_wait_time = self.calculate_intercept_time(self.tanker, next_shuttle)

                if intercept_wait_time == float('inf'):
                     print(f"Warning: Cannot intercept shuttle {next_shuttle.id} after transfer (relative speed issue?). Skipping recovery.")
                elif intercept_wait_time > 1e-3:
                     print(f"  Waiting additional {intercept_wait_time:.2f}s for final rendezvous...")
                     self.tanker.add_event(
                         self.mission_clock,
                         f"Final rendezvous wait ({intercept_wait_time:.2f}s) in orbit {self.orbit_index_to_string(current_orbit_idx)} for {next_shuttle.id}"
                     )
                     wait_traj = self.wait_in_orbit(intercept_wait_time)
                     self.tanker_mission_trajectory.extend(wait_traj)
                     # 6. Recover the targeted shuttle after final wait
                     print(f"Attempting recovery of shuttle {next_shuttle.id}...")
                     self.recover_shuttle(next_shuttle)
                else:
                     # Intercept time is negligible, recover immediately
                     print(f"Tanker aligned with shuttle {next_shuttle.id} after transfer. Attempting immediate recovery...")
                     # 6. Recover the targeted shuttle immediately
                     self.recover_shuttle(next_shuttle)

            else:
                # --- No specific shuttle target found / Transfer failed ---
                # Option: Just transfer down without recovery? Or stop?
                # Current behaviour: Try to transfer down anyway.
                print(f"  No optimal shuttle target found or transfer calculation failed for orbit {self.orbit_index_to_string(current_orbit_idx - 1)}.")
                print(f"  Attempting transfer to orbit {self.orbit_index_to_string(current_orbit_idx - 1)} without specific rendezvous.")

                # Calculate transfer to the next lower orbit directly
                target_lower_orbit = self.orbits[current_orbit_idx - 1]
                # Check for valid transfer
                if abs(self.tanker.radius - target_lower_orbit.radius) < 1e-3:
                     print(f"  Error: Cannot transfer to identical radius orbit {target_lower_orbit.radius}. Stopping return.")
                     break # Stop return if cannot transfer down

                transfer_down = HohmannTransfer(self.tanker.radius, target_lower_orbit.radius)
                if transfer_down.transfer_time < 1e-9:
                     print(f"  Error: Zero transfer time calculated for downward transfer. Stopping return.")
                     break

                self.tanker.add_event(
                     self.mission_clock,
                     f"Beginning transfer from orbit {self.orbit_index_to_string(current_orbit_idx)} to orbit {self.orbit_index_to_string(current_orbit_idx - 1)} (no target recovery)"
                )
                transfer_traj = self.execute_hohmann_transfer(transfer_down)
                self.tanker_mission_trajectory.extend(transfer_traj)

                # Update orbit index
                current_orbit_idx -= 1
                print(f"  Completed transfer. Now in orbit {self.orbit_index_to_string(current_orbit_idx)}.")

                # Verify transfer success
                if self.find_current_orbit_index() != current_orbit_idx:
                     print(f"Error: Downward transfer failed to reach orbit index {current_orbit_idx}.")
                     self.tanker.radius = self.orbits[current_orbit_idx].radius
                     self.tanker.speed = (np.sqrt(MU / self.tanker.radius) / self.tanker.radius) if self.tanker.radius > 0 else 0
                     print(f"  Forcing tanker state to orbit {current_orbit_idx}.")
                     forced_pos = self.tanker.position()
                     self.tanker_mission_trajectory.append((self.mission_clock, forced_pos[0], forced_pos[1]))
                 # Note: No shuttle recovery attempted here as no target was identified.

        print("\n=== Descent Loop Complete ===")


        # --- LOWEST ORBIT RECOVERY ---
        # After the loop, tanker should be in the lowest orbit (index 0)
        reentry_phasing_complete = False # Flag to indicate if phasing wait is done
        if current_orbit_idx == 0:
             lowest_orbit = self.orbits[0]
             lowest_orbit_shuttle = None
             for s in lowest_orbit.shuttles:
                 # Find the shuttle belonging to this orbit that was deployed and not yet recovered
                 if s in self.tanker.shuttles_deployed and s not in self.tanker.shuttles_recovered:
                     lowest_orbit_shuttle = s
                     break

             if lowest_orbit_shuttle:
                 print(f"\n--- Waiting in lowest orbit ({self.orbit_index_to_string(0)}) for final shuttle rendezvous ---")
                 # Calculate wait time for intercept in the *same* orbit
                 wait_time_low = self.calculate_intercept_time(self.tanker, lowest_orbit_shuttle)

                 if wait_time_low == float('inf'):
                     print(f"Warning: Cannot intercept shuttle {lowest_orbit_shuttle.id} in lowest orbit (relative speed issue?). Skipping recovery.")
                 elif wait_time_low > 1e-3:
                     self.tanker.add_event(
                         self.mission_clock,
                         f"Waiting {wait_time_low:.2f}s in lowest orbit for shuttle {lowest_orbit_shuttle.id}"
                     )
                     wait_traj = self.wait_in_orbit(wait_time_low)
                     self.tanker_mission_trajectory.extend(wait_traj)
                     print(f"Attempting recovery of shuttle {lowest_orbit_shuttle.id} in lowest orbit...")
                     self.recover_shuttle(lowest_orbit_shuttle)

                 # --- Pre-Reentry Phasing Wait (if shuttle was recovered) ---
                 if lowest_orbit_shuttle in self.tanker.shuttles_recovered:
                     print(f"\n--- Calculating pre-reentry phasing wait in orbit {self.orbit_index_to_string(0)} ---")
                     # Target landing angle
                     target_landing_angle = self.initial_launch_angle if self.initial_launch_angle is not None else 0.0
                     # Estimate angular travel during reentry itself (using average speed needed)
                     estimated_reentry_duration = 1200.0 # Match duration used in simulate_reentry
                     shortest_delta_angle_reentry = target_landing_angle - self.tanker.angle # Angle from current pos to landing
                     shortest_delta_angle_reentry = (shortest_delta_angle_reentry + np.pi) % (2 * np.pi) - np.pi
                     # Target average angular velocity during reentry
                     target_avg_reentry_vel = shortest_delta_angle_reentry / estimated_reentry_duration if estimated_reentry_duration > 1e-6 else 0.0
                     # Heuristic: Start reentry when landing site is roughly angular_travel/2 'behind'
                     # A simpler heuristic: Start reentry when tanker angle is PI radians away from target landing angle?
                     # Let's try aiming to start when tanker is PI/2 radians *behind* target landing angle (target is ahead)
                     target_reentry_start_angle = (target_landing_angle - np.pi/2) % (2 * np.pi)

                     # Calculate wait time needed to drift to this start angle
                     angle_to_drift = (target_reentry_start_angle - self.tanker.angle) % (2*np.pi)
                     wait_time_phasing = angle_to_drift / self.tanker.speed if abs(self.tanker.speed) > 1e-9 else float('inf')

                     # Ensure wait time is positive
                     if wait_time_phasing < -1e-9:
                         orbit_period_phys = (2* np.pi) / abs(self.tanker.speed) if abs(self.tanker.speed) > 1e-9 else float('inf')
                         if orbit_period_phys != float('inf'):
                             wait_time_phasing += orbit_period_phys
                         else:
                             wait_time_phasing = float('inf') # Cannot phase if speed is zero

                     wait_time_phasing = max(0, wait_time_phasing) # Ensure non-negative

                     if wait_time_phasing == float('inf') or wait_time_phasing > 86400: # Limit wait to 1 day
                         print(f"Warning: Cannot calculate pre-reentry phase wait or wait time is excessive ({wait_time_phasing:.2f}s). Proceeding directly to reentry.")
                     elif wait_time_phasing > 1e-3:
                         print(f"Waiting {wait_time_phasing:.2f}s for reentry phasing...")
                         self.tanker.add_event(
                             self.mission_clock,
                             f"Waiting {wait_time_phasing:.2f}s in lowest orbit for reentry phasing to angle {target_reentry_start_angle:.2f} rad"
                         )
                         wait_traj = self.wait_in_orbit(wait_time_phasing)
                         self.tanker_mission_trajectory.extend(wait_traj)
                         reentry_phasing_complete = True # Mark phasing as done
                     else:
                         print("Tanker already phased for reentry. Proceeding directly.")
                         reentry_phasing_complete = True # Mark phasing as done (no wait needed)
                 else:
                     print("Skipping reentry phasing wait as lowest orbit shuttle was not recovered.")

             else:
                 print("Warning: Could not find the deployed shuttle in the lowest orbit to recover.")
        else:
             print(f"Warning: Tanker not in lowest orbit (index {current_orbit_idx}) after descent loop. Skipping lowest orbit recovery.")


        # --- Final Reentry Phase ---
        # Check if tanker is actually in the lowest orbit before re-entering
        if self.find_current_orbit_index() == 0:
            print(f"\n=== Starting Reentry Phase from orbit {self.orbit_index_to_string(0)} ===")
            # Use the initially stored launch pad angle for landing target
            target_landing_angle = self.initial_launch_angle if self.initial_launch_angle is not None else 0.0
            self.tanker.add_event(
                self.mission_clock,
                f"Beginning reentry procedure targeting landing angle {target_landing_angle:.2f} rad"
            )
            reentry_traj = self.simulate_reentry(self.tanker, target_landing_angle)
            self.tanker_mission_trajectory.extend(reentry_traj)
        else:
            print(f"\nError: Tanker not in lowest orbit (index {self.find_current_orbit_index()}) at end of return phase. Cannot perform reentry.")


        # --- Mission Summary ---
        shuttles_deployed_count = len(self.tanker.shuttles_deployed)
        shuttles_recovered_count = len(self.tanker.shuttles_recovered)
        mission_duration = self.mission_clock

        print("\n===== MISSION SUMMARY =====")
        print(f"Mission duration: {mission_duration:.2f} seconds")
        print(f"Shuttles deployed: {shuttles_deployed_count}")
        print(f"Shuttles recovered: {shuttles_recovered_count}")
        if shuttles_deployed_count > 0:
            recovery_rate = shuttles_recovered_count / shuttles_deployed_count * 100
            print(f"Recovery rate: {recovery_rate:.1f}%")
        else:
            print("Recovery rate: N/A (No shuttles deployed)")
        print(f"Final tanker status: Active={self.tanker.active}, Radius={self.tanker.radius:.1f}, Angle={self.tanker.angle:.2f}")
        print("==========================\n")

    def visualize(self):
        """Create an animation of the mission (time is physical seconds)"""
        fig, ax = plt.subplots(figsize=(11, 10)) # Slightly wider for text
        ax.set_aspect('equal')

        # Plot the planet
        planet = plt.Circle((0, 0), self.planet_radius, color='royalblue', alpha=0.6)
        ax.add_patch(planet)

        # Plot orbits
        for i, orbit in enumerate(self.orbits):
            theta = np.linspace(0, 2*np.pi, 100)
            x = orbit.radius * np.cos(theta)
            y = orbit.radius * np.sin(theta)
            ax.plot(x, y, 'k--', alpha=0.3, linewidth=1, label=f'Orbit {i}' if i == 0 else None) # Label only first orbit line

        # Plot all launch pads, not just the selected one
        for i, pad in enumerate(self.all_launch_pads):
            pad_x = self.planet_radius * np.cos(pad.angle)
            pad_y = self.planet_radius * np.sin(pad.angle)
            # Highlight the selected launch pad with a different color/marker
            is_selected = abs(pad.angle - self.initial_launch_angle) < 0.01
            marker_color = 'lime' if is_selected else 'cyan'
            marker_size = 8 if is_selected else 7
            ax.plot(pad_x, pad_y, 's', color=marker_color, markersize=marker_size, 
                   label='Selected Launch Pad' if is_selected and i == 0 else ('Other Launch Pad' if not is_selected and i == 0 else None))

        # Set plot limits based on the largest orbit
        max_radius = max(orbit.radius for orbit in self.orbits) * 1.15 if self.orbits else self.planet_radius * 2
        ax.set_xlim(-max_radius, max_radius)
        ax.set_ylim(-max_radius, max_radius)
        ax.grid(True, linestyle=':', alpha=0.6)
        title_text = f'Multi-Orbit Simulation - Fuel: {self.get_total_fuel_liters():,.0f} L, Pad: {self.initial_launch_angle:.2f} rad'
        ax.set_title(title_text, fontsize=14)
        ax.set_xlabel("X (km)")
        ax.set_ylabel("Y (km)")

        # Animation setup
        # Satellites (red circles)
        satellite_markers = [ax.plot([], [], 'ro', markersize=5, label='Satellite' if i == 0 else "")[0] for i, _ in enumerate(self.satellites)]
        # Shuttles (yellow circles - hollow when recovered?)
        # Keep separate markers for active and recovered shuttles for different styles
        shuttle_active_markers = [ax.plot([], [], 'yo', markersize=6, label='Active Shuttle' if i == 0 else "")[0] for i, _ in enumerate(self.shuttles)]
        # Shuttle recovered markers (e.g., yellow 'x')
        # shuttle_recovered_markers = [ax.plot([], [], 'yx', markersize=6, label='Recovered Shuttle' if i == 0 else "")[0] for i, _ in enumerate(self.shuttles)]

        # Tanker (green circle)
        tanker_marker, = ax.plot([], [], 'go', markersize=8, label='Tanker')
        # Tanker historical path (thinner green line)
        tanker_full_path_line, = ax.plot([], [], 'g-', linewidth=1, alpha=0.5, label='Tanker Path')

        # Text display for mission time (seconds) and status
        time_text = ax.text(0.02, 0.98, '', transform=ax.transAxes, fontsize=10, verticalalignment='top', bbox=dict(boxstyle='round,pad=0.3', fc='wheat', alpha=0.5))
        status_text = ax.text(0.02, 0.92, '', transform=ax.transAxes, fontsize=10, verticalalignment='top', bbox=dict(boxstyle='round,pad=0.3', fc='wheat', alpha=0.5))
        # Add text display for total Delta-V
        delta_v_text = ax.text(0.02, 0.86, '', transform=ax.transAxes, fontsize=10, verticalalignment='top', bbox=dict(boxstyle='round,pad=0.3', fc='wheat', alpha=0.5))
        # Add text for launch pad efficiency
        efficiency_text = ax.text(0.02, 0.80, f'Launch Pad Efficiency: {self.launch_pad_efficiency:.2f}', transform=ax.transAxes, fontsize=10, verticalalignment='top', bbox=dict(boxstyle='round,pad=0.3', fc='wheat', alpha=0.5))

        # Add legend
        handles, labels = ax.get_legend_handles_labels()
        # Add orbit line to legend manually if orbits exist
        if self.orbits:
             orbit_line, = ax.plot([],[], 'k--', alpha=0.5, linewidth=1, label='Orbit Path')
             handles.append(orbit_line)
             labels.append('Orbit Path')
        fig.legend(handles, labels, loc='upper right', fontsize=9, bbox_to_anchor=(0.99, 0.98))

        # Total number of animation frames
        num_frames = 1000 # Increased frames for smoother animation
        # Or base on trajectory length: num_frames = max(500, len(self.tanker_mission_trajectory))
        # num_frames = min(num_frames, 2000) # Cap frames

        def init():
            """Initialize animation elements"""
            tanker_marker.set_data([], [])
            tanker_full_path_line.set_data([], [])
            time_text.set_text('')
            status_text.set_text('')
            delta_v_text.set_text('') # Initialize Delta-V text

            for marker in satellite_markers:
                marker.set_data([], [])
            for marker in shuttle_active_markers:
                marker.set_data([], [])
            # for marker in shuttle_recovered_markers:
            #     marker.set_data([], [])

            all_elements = [tanker_marker, tanker_full_path_line, time_text, status_text, delta_v_text, efficiency_text] + \
                           satellite_markers + shuttle_active_markers #+ shuttle_recovered_markers
            return all_elements

        def update(frame):
            """Update animation for the given frame"""
            num_trajectory_points = len(self.tanker_mission_trajectory)
            if num_trajectory_points < 2: return init() # Need trajectory

            # --- Interpolation Logic ---
            # Interpolates based on frame number across the trajectory points
            # target_traj_pos, idx0, idx1, interp_ratio calculated as before
            target_traj_pos = (frame / (num_frames - 1)) * (num_trajectory_points - 1)
            idx0 = int(target_traj_pos)
            idx0 = min(max(0, idx0), num_trajectory_points - 2)
            idx1 = idx0 + 1
            interp_ratio = target_traj_pos - idx0

            # Trajectory points now have time in physical seconds
            time0, x0, y0 = self.tanker_mission_trajectory[idx0]
            time1, x1, y1 = self.tanker_mission_trajectory[idx1]

            # Interpolate time (physical seconds) and tanker position
            estimated_mission_time = time0 + interp_ratio * (time1 - time0) # physical seconds
            current_tanker_x = x0 + interp_ratio * (x1 - x0)
            current_tanker_y = y0 + interp_ratio * (y1 - y0)
            # --- End Interpolation Logic ---


            # Update satellite positions based on interpolated time (physical seconds)
            for i, satellite in enumerate(self.satellites):
                if satellite.active:
                    # satellite.speed is physical angular speed (rad/s)
                    satellite_angle = (satellite.initial_angle + satellite.speed * estimated_mission_time) % (2 * np.pi)
                    sat_x = satellite.radius * np.cos(satellite_angle)
                    sat_y = satellite.radius * np.sin(satellite_angle)
                    satellite_markers[i].set_data([sat_x], [sat_y])
                else:
                    satellite_markers[i].set_data([], [])


            # Update shuttle positions based on interpolated time (physical seconds)
            for i, shuttle in enumerate(self.shuttles):
                # deployment_time and recovery_time are physical seconds
                is_deployed = shuttle.deployed and shuttle.deployment_time is not None and estimated_mission_time >= shuttle.deployment_time
                is_recovered = shuttle.recovery_time is not None and estimated_mission_time >= shuttle.recovery_time

                if is_deployed and not is_recovered:
                    # time_since_deployment is physical seconds
                    time_since_deployment = estimated_mission_time - shuttle.deployment_time
                    # shuttle.speed is physical angular speed (rad/s)
                    shuttle_angle = (shuttle.initial_angle + shuttle.speed * time_since_deployment) % (2 * np.pi)
                    shuttle_x = shuttle.radius * np.cos(shuttle_angle)
                    shuttle_y = shuttle.radius * np.sin(shuttle_angle)
                    shuttle_active_markers[i].set_data([shuttle_x], [shuttle_y])
                else:
                    shuttle_active_markers[i].set_data([], [])


            # Update tanker position
            # Check if tanker is still active (hasn't landed based on physical time)
            final_event_time = self.tanker.mission_events[-1][0] if self.tanker.mission_events else 0
            if self.tanker.active or estimated_mission_time < final_event_time:
                 tanker_marker.set_data([current_tanker_x], [current_tanker_y])
            else:
                 tanker_marker.set_data([],[])


            # Update tanker's full historical path line
            # Draw path up to the *segment* defined by idx1
            trajectory_slice = self.tanker_mission_trajectory[:idx1 + 1] # Points up to idx1
            if trajectory_slice:
                 # Add the *current interpolated point* for a smoother tail
                 path_x = [pos[1] for pos in trajectory_slice] + [current_tanker_x]
                 path_y = [pos[2] for pos in trajectory_slice] + [current_tanker_y]
                 tanker_full_path_line.set_data(path_x, path_y)
            else:
                 tanker_full_path_line.set_data([], [])


            # Update mission time text (displaying seconds)
            time_text.set_text(f'Time: {estimated_mission_time:.1f} seconds')

            # Update mission status text based on events (event times are physical seconds)
            status = "Pre-launch"
            for event_time, event_desc in self.tanker.mission_events:
                 if event_time <= estimated_mission_time + 1e-6: # Add tolerance
                     status = event_desc
                 else:
                     break # Events are ordered by time
            status_text.set_text(f'Status: {status}')

            # Update total Fuel text (using the helper method)
            fuel_liters = self.get_total_fuel_liters()
            delta_v_text.set_text(f'Fuel Used: {fuel_liters:,.0f} L') # Renamed the text element conceptually

            all_elements = [tanker_marker, tanker_full_path_line, time_text, status_text, delta_v_text, efficiency_text] + \
                           satellite_markers + shuttle_active_markers #+ shuttle_recovered_markers
            return all_elements

        # Create the animation
        ani = FuncAnimation(
            fig,
            update,
            frames=num_frames,
            init_func=init,
            blit=False,
            interval=30 # Controls playback speed (ms per frame)
        )

        plt.tight_layout(rect=[0, 0, 0.95, 1]) # Adjust layout to prevent legend overlap
        return fig, ani

# --- Example Usage ---
if __name__ == "__main__":
    print("Setting up mission simulation...")

    # --- Define Common Mission Parameters ---
    initial_launch_pads = [
        LaunchPad(EARTH_RADIUS, 0),          # 0 degrees
        LaunchPad(EARTH_RADIUS, np.pi / 2),  # 90 degrees
        LaunchPad(EARTH_RADIUS, np.pi),      # 180 degrees
        LaunchPad(EARTH_RADIUS, 3*np.pi/2),  # 270 degrees
        LaunchPad(EARTH_RADIUS, np.pi/4),    # 45 degrees
    ]
    orbit_altitudes = [500, 3000, 8000] # Altitudes in km
    initial_satellites_config = {
        0: [np.deg2rad(0), np.deg2rad(120), np.deg2rad(240)], # Orbit 0 angles
        1: [np.deg2rad(90), np.deg2rad(270)],               # Orbit 1 angles
        2: [np.deg2rad(180)]                                # Orbit 2 angles
    }
    # ------------------------------------->

    best_sim_instance = None
    min_fuel_usage = float('inf')
    best_launch_pad_angle = None
    fuel_results = {}  # Track fuel usage by launch pad angle

    print(f"\nSimulating mission for {len(initial_launch_pads)} launch pads...")

    for i, launch_pad in enumerate(initial_launch_pads):
        print(f"\n--- Running Simulation for Launch Pad {i+1} (Angle: {launch_pad.angle:.2f} rad) ---")

        # Create a fresh tanker and simulation environment for each run
        # Note: Tanker initial angle (0) is irrelevant here, will be set by sim.simulate_mission
        tanker = Tanker(EARTH_RADIUS, 0, 0)
        sim = SimulateMission(EARTH_RADIUS, tanker)

        # Add ONLY the current launch pad to this simulation instance
        sim.add_launch_pad(launch_pad)
        
        # Store all launch pads for visualization
        sim.add_all_launch_pads(initial_launch_pads)

        # Add orbits
        orbits = [sim.add_orbit(EARTH_RADIUS + alt) for alt in orbit_altitudes]

        # Add satellites to orbits for this simulation instance
        satellite_count = 0
        for orbit_idx, angles in initial_satellites_config.items():
            if orbit_idx < len(orbits):
                for angle in angles:
                    sim.add_satellite(orbits[orbit_idx], angle)
                    satellite_count += 1
            else:
                 print(f"  Warning: Orbit index {orbit_idx} out of range for satellite config.")

        # --- Run Simulation ---
        print("  Starting mission simulation sequence...")
        try:
            # Reset simulation-specific state before each run
            sim.mission_clock = 0.0
            sim.total_delta_v = 0.0
            sim.tanker_mission_trajectory = []
            sim.tanker.mission_events = []
            sim.tanker.shuttles_deployed = []
            sim.tanker.shuttles_recovered = []
            sim.tanker.active = True # Ensure tanker is reset to active
            
            # Add random efficiency factor to make each run different
            # This is a simplified model - in reality, it would depend on physics/orbital mechanics
            sim.launch_pad_efficiency = 0.8 + 0.4 * (abs(launch_pad.angle) % np.pi) / np.pi
            # Launch efficiency now varies from 0.8 to 1.2 based on launch pad angle

            sim.simulate_mission()
            
            # Calculate fuel usage for this run
            fuel_usage = sim.get_total_fuel_liters()
            fuel_results[launch_pad.angle] = fuel_usage
            
            print("  Mission simulation sequence complete.")
            print(f"  Total Delta-V for this run: {sim.total_delta_v:.3f} km/s")
            print(f"  Launch pad efficiency: {sim.launch_pad_efficiency:.2f}")
            print(f"  Estimated Fuel Used: {fuel_usage:,.0f} L")

            # Check if this is the best run so far based on fuel usage
            if fuel_usage < min_fuel_usage:
                min_fuel_usage = fuel_usage
                best_sim_instance = sim
                best_launch_pad_angle = launch_pad.angle

        except Exception as e:
            print(f"\n  --- SIMULATION FAILED (Launch Pad {i+1}) ---")
            print(f"  An error occurred: {e}")
            import traceback
            traceback.print_exc(limit=2) # Limit traceback length
            print("  --------------------------------------")
            # Continue to the next launch pad

    # --- Display Fuel Results Summary ---
    print("\n--- Fuel Usage Results ---")
    for angle, fuel in sorted(fuel_results.items()):
        print(f"Launch Pad Angle: {angle:.2f} rad, Fuel Used: {fuel:,.0f} L")
    
    print("\n--- Simulation Runs Complete ---")

    # --- Results Summary ---
    if best_sim_instance:
        print(f"Optimal Launch Pad Angle: {best_launch_pad_angle:.2f} rad")
        print(f"Minimum Estimated Fuel: {min_fuel_usage:,.0f} L")

        # --- Visualize Only the Best Run ---
        if best_sim_instance.tanker_mission_trajectory and len(best_sim_instance.tanker_mission_trajectory) > 1:
             print("\nGenerating visualization for the optimal trajectory...")
             try:
                 # Pass the best sim instance to visualize
                 fig, ani = best_sim_instance.visualize() # Use the best sim instance directly
                 plt.show() # Display the animation window
             except Exception as e:
                 print(f"\n--- VISUALIZATION FAILED ---")
                 print(f"An error occurred during visualization: {e}")
                 import traceback
                 traceback.print_exc()
                 print("----------------------------")
        else:
             print("\nSkipping visualization: No valid tanker trajectory generated for the optimal run.")

    else:
        print("\nNo successful simulation runs completed. Cannot determine optimal launch or visualize.")


    print("\nSimulation finished.")